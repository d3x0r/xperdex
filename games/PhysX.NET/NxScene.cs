//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Copyright (c) 2007-2008
// Available under the terms of the
// Eclipse Public License with GPL exception
// See enclosed license file for more information
namespace PhysX.NET
{
	using System;
	using System.Runtime.InteropServices;
	
	
	public class NxScene : DoxyBindObject
	{
		
		internal NxScene(IntPtr ptr) : 
				base(ptr)
		{
		}
		
		/// <summary>Creates an actor in this scene. </summary>
		/// <param name="desc">Descriptor for actor to create. See NxActorDescBase</param>
		public virtual NxActor createActor(NxActorDescBase desc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxActor.GetClass(NxScene_createActor_INVOKE(ClassPointer, doSetFunctionPointers, (desc!=null ? desc.ClassPointer : NullRef)));
		}
		
		private IntPtr createActor_virtual(IntPtr desc)
		{
			return createActor(NxActorDescBase.GetClass(desc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createActor_0_delegate(IntPtr desc);
		
		
		
		
		
		
		private createActor_0_delegate createActor_0_delegatefield;
		
		/// <summary>Deletes the specified actor. </summary>
		/// <param name="actor">The actor to release.</param>
		public virtual void releaseActor(NxActor actor)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseActor_INVOKE(ClassPointer, doSetFunctionPointers, (actor!=null ? actor.ClassPointer : NullRef));
		}
		
		private void releaseActor_virtual(IntPtr actor)
		{
			releaseActor(NxActor.GetClass(actor));
		}
		
		delegate void releaseActor_1_delegate(IntPtr actor);
		
		
		
		
		
		
		private releaseActor_1_delegate releaseActor_1_delegatefield;
		
		/// <summary>Creates a joint. </summary>
		/// <param name="jointDesc">The descriptor for the joint to create. E.g. NxSphericalJointDesc,NxRevoluteJointDesc etc </param>
		public virtual NxJoint createJoint(NxJointDesc jointDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxJoint.GetClass(NxScene_createJoint_INVOKE(ClassPointer, doSetFunctionPointers, (jointDesc!=null ? jointDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createJoint_virtual(IntPtr jointDesc)
		{
			return createJoint(NxJointDesc.GetClass(jointDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createJoint_2_delegate(IntPtr jointDesc);
		
		
		
		
		
		
		private createJoint_2_delegate createJoint_2_delegatefield;
		
		/// <summary>Deletes the specified joint. </summary>
		/// <param name="joint">The joint to release.</param>
		public virtual void releaseJoint(NxJoint joint)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseJoint_INVOKE(ClassPointer, doSetFunctionPointers, (joint!=null ? joint.ClassPointer : NullRef));
		}
		
		private void releaseJoint_virtual(IntPtr joint)
		{
			releaseJoint(NxJoint.GetClass(joint));
		}
		
		delegate void releaseJoint_3_delegate(IntPtr joint);
		
		
		
		
		
		
		private releaseJoint_3_delegate releaseJoint_3_delegatefield;
		
		/// <summary>Deprecated. Use createEffector() instead. </summary>
		/// <param name="springDesc">The descriptor for the spring and damper effector to create. See NxSpringAndDamperEffectorDesc. </param>
		public virtual NxSpringAndDamperEffector createSpringAndDamperEffector(NxSpringAndDamperEffectorDesc springDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxSpringAndDamperEffector.GetClass(NxScene_createSpringAndDamperEffector_INVOKE(ClassPointer, doSetFunctionPointers, (springDesc!=null ? springDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createSpringAndDamperEffector_virtual(IntPtr springDesc)
		{
			return createSpringAndDamperEffector(NxSpringAndDamperEffectorDesc.GetClass(springDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createSpringAndDamperEffector_4_delegate(IntPtr springDesc);
		
		
		
		
		
		
		private createSpringAndDamperEffector_4_delegate createSpringAndDamperEffector_4_delegatefield;
		
		/// <summary>Creates an effector. </summary>
		/// <param name="desc">The descriptor for the effector to create. See NxEffectorDesc. </param>
		public virtual NxEffector createEffector(NxEffectorDesc desc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxEffector.GetClass(NxScene_createEffector_INVOKE(ClassPointer, doSetFunctionPointers, (desc!=null ? desc.ClassPointer : NullRef)));
		}
		
		private IntPtr createEffector_virtual(IntPtr desc)
		{
			return createEffector(NxEffectorDesc.GetClass(desc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createEffector_5_delegate(IntPtr desc);
		
		
		
		
		
		
		private createEffector_5_delegate createEffector_5_delegatefield;
		
		/// <summary>Deletes the effector passed. </summary>
		/// <param name="effector">The effector to delete.</param>
		public virtual void releaseEffector(NxEffector effector)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseEffector_INVOKE(ClassPointer, doSetFunctionPointers, (effector!=null ? effector.ClassPointer : NullRef));
		}
		
		private void releaseEffector_virtual(IntPtr effector)
		{
			releaseEffector(NxEffector.GetClass(effector));
		}
		
		delegate void releaseEffector_6_delegate(IntPtr effector);
		
		
		
		
		
		
		private releaseEffector_6_delegate releaseEffector_6_delegatefield;
		
		/// <summary>Creates a force field. </summary>
		/// <param name="forceFieldDesc">The descriptor for the force field to create. See NxForceFieldDesc. </param>
		public virtual NxForceField createForceField(NxForceFieldDesc forceFieldDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxForceField.GetClass(NxScene_createForceField_INVOKE(ClassPointer, doSetFunctionPointers, (forceFieldDesc!=null ? forceFieldDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createForceField_virtual(IntPtr forceFieldDesc)
		{
			return createForceField(NxForceFieldDesc.GetClass(forceFieldDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createForceField_7_delegate(IntPtr forceFieldDesc);
		
		
		
		
		
		
		private createForceField_7_delegate createForceField_7_delegatefield;
		
		/// <summary>Deletes the force field passed. </summary>
		/// <param name="forceField">The effector to delete.</param>
		public virtual void releaseForceField(NxForceField forceField)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseForceField_INVOKE(ClassPointer, doSetFunctionPointers, (forceField!=null ? forceField.ClassPointer : NullRef));
		}
		
		private void releaseForceField_virtual(IntPtr forceField)
		{
			releaseForceField(NxForceField.GetClass(forceField));
		}
		
		delegate void releaseForceField_8_delegate(IntPtr forceField);
		
		
		
		
		
		
		private releaseForceField_8_delegate releaseForceField_8_delegatefield;
		
		/// <summary>Gets the number of force fields in the scene. </summary>
		public virtual uint getNbForceFields()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbForceFields_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbForceFields_virtual()
		{
			return getNbForceFields();
		}
		
		delegate uint getNbForceFields_9_delegate();
		
		
		
		
		
		
		private getNbForceFields_9_delegate getNbForceFields_9_delegatefield;
		
		/// <summary>Gets the force fields in the scene. </summary>
		public virtual DoxyBindArray<NxForceField> getForceFields()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getForceFields_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private IntPtr[] getForceFields_virtual()
		{
			return getForceFields();
		}
		
		delegate IntPtr[] getForceFields_10_delegate();
		
		
		
		
		
		
		private getForceFields_10_delegate getForceFields_10_delegatefield;
		
		/// <summary>creates a forcefield kernel which uses the same linear function as pre 2.8 force fields </summary>
		/// <param name="kernelDesc">The linear kernel desc to use to create a linear kernel for force fields. See NxForceFieldLinearKernelDesc. </param>
		public virtual NxForceFieldLinearKernel createForceFieldLinearKernel(NxForceFieldLinearKernelDesc kernelDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxForceFieldLinearKernel.GetClass(NxScene_createForceFieldLinearKernel_INVOKE(ClassPointer, doSetFunctionPointers, (kernelDesc!=null ? kernelDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createForceFieldLinearKernel_virtual(IntPtr kernelDesc)
		{
			return createForceFieldLinearKernel(NxForceFieldLinearKernelDesc.GetClass(kernelDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createForceFieldLinearKernel_11_delegate(IntPtr kernelDesc);
		
		
		
		
		
		
		private createForceFieldLinearKernel_11_delegate createForceFieldLinearKernel_11_delegatefield;
		
		/// <summary>releases a linear force field kernel </summary>
		/// <param name="kernel">to be released. </param>
		public virtual void releaseForceFieldLinearKernel(NxForceFieldLinearKernel kernel)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseForceFieldLinearKernel_INVOKE(ClassPointer, doSetFunctionPointers, (kernel!=null ? kernel.ClassPointer : NullRef));
		}
		
		private void releaseForceFieldLinearKernel_virtual(IntPtr kernel)
		{
			releaseForceFieldLinearKernel(NxForceFieldLinearKernel.GetClass(kernel));
		}
		
		delegate void releaseForceFieldLinearKernel_12_delegate(IntPtr kernel);
		
		
		
		
		
		
		private releaseForceFieldLinearKernel_12_delegate releaseForceFieldLinearKernel_12_delegatefield;
		
		/// <summary>Returns the number of linear kernels in the scene. </summary>
		public virtual uint getNbForceFieldLinearKernels()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbForceFieldLinearKernels_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbForceFieldLinearKernels_virtual()
		{
			return getNbForceFieldLinearKernels();
		}
		
		delegate uint getNbForceFieldLinearKernels_13_delegate();
		
		
		
		
		
		
		private getNbForceFieldLinearKernels_13_delegate getNbForceFieldLinearKernels_13_delegatefield;
		
		/// <summary>Restarts the linear kernels iterator so that the next call to getNextForceFieldLinearKernel(). </summary>
		public virtual void resetForceFieldLinearKernelsIterator()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_resetForceFieldLinearKernelsIterator_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void resetForceFieldLinearKernelsIterator_virtual()
		{
			resetForceFieldLinearKernelsIterator();
		}
		
		delegate void resetForceFieldLinearKernelsIterator_14_delegate();
		
		
		
		
		
		
		private resetForceFieldLinearKernelsIterator_14_delegate resetForceFieldLinearKernelsIterator_14_delegatefield;
		
		/// <summary>Retrieves the next linear kernel when iterating. </summary>
		public virtual NxForceFieldLinearKernel getNextForceFieldLinearKernel()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxForceFieldLinearKernel.GetClass(NxScene_getNextForceFieldLinearKernel_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getNextForceFieldLinearKernel_virtual()
		{
			return getNextForceFieldLinearKernel().ClassPointer.Handle;
		}
		
		delegate IntPtr getNextForceFieldLinearKernel_15_delegate();
		
		
		
		
		
		
		private getNextForceFieldLinearKernel_15_delegate getNextForceFieldLinearKernel_15_delegatefield;
		
		/// <summary>Creates a new force field shape group. </summary>
		/// <param name="desc">The force field group descriptor. See NxForceFieldShapeGroupDesc. </param>
		public virtual NxForceFieldShapeGroup createForceFieldShapeGroup(NxForceFieldShapeGroupDesc desc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxForceFieldShapeGroup.GetClass(NxScene_createForceFieldShapeGroup_INVOKE(ClassPointer, doSetFunctionPointers, (desc!=null ? desc.ClassPointer : NullRef)));
		}
		
		private IntPtr createForceFieldShapeGroup_virtual(IntPtr desc)
		{
			return createForceFieldShapeGroup(NxForceFieldShapeGroupDesc.GetClass(desc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createForceFieldShapeGroup_16_delegate(IntPtr desc);
		
		
		
		
		
		
		private createForceFieldShapeGroup_16_delegate createForceFieldShapeGroup_16_delegatefield;
		
		/// <summary>Releases a force field shape group. </summary>
		/// <param name="group">The group which is to be relased. See NxForceFieldShapeGroup.</param>
		public virtual void releaseForceFieldShapeGroup(NxForceFieldShapeGroup group)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseForceFieldShapeGroup_INVOKE(ClassPointer, doSetFunctionPointers, (group!=null ? group.ClassPointer : NullRef));
		}
		
		private void releaseForceFieldShapeGroup_virtual(IntPtr group)
		{
			releaseForceFieldShapeGroup(NxForceFieldShapeGroup.GetClass(group));
		}
		
		delegate void releaseForceFieldShapeGroup_17_delegate(IntPtr group);
		
		
		
		
		
		
		private releaseForceFieldShapeGroup_17_delegate releaseForceFieldShapeGroup_17_delegatefield;
		
		/// <summary>Returns the number of shape groups in the scene. </summary>
		public virtual uint getNbForceFieldShapeGroups()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbForceFieldShapeGroups_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbForceFieldShapeGroups_virtual()
		{
			return getNbForceFieldShapeGroups();
		}
		
		delegate uint getNbForceFieldShapeGroups_18_delegate();
		
		
		
		
		
		
		private getNbForceFieldShapeGroups_18_delegate getNbForceFieldShapeGroups_18_delegatefield;
		
		/// <summary>Restarts the shape groups iterator so that the next call to getNextForceFieldShapeGroup() returns the first shape group in the force scene. </summary>
		public virtual void resetForceFieldShapeGroupsIterator()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_resetForceFieldShapeGroupsIterator_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void resetForceFieldShapeGroupsIterator_virtual()
		{
			resetForceFieldShapeGroupsIterator();
		}
		
		delegate void resetForceFieldShapeGroupsIterator_19_delegate();
		
		
		
		
		
		
		private resetForceFieldShapeGroupsIterator_19_delegate resetForceFieldShapeGroupsIterator_19_delegatefield;
		
		/// <summary>Retrieves the next shape group when iterating. </summary>
		public virtual NxForceFieldShapeGroup getNextForceFieldShapeGroup()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxForceFieldShapeGroup.GetClass(NxScene_getNextForceFieldShapeGroup_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getNextForceFieldShapeGroup_virtual()
		{
			return getNextForceFieldShapeGroup().ClassPointer.Handle;
		}
		
		delegate IntPtr getNextForceFieldShapeGroup_20_delegate();
		
		
		
		
		
		
		private getNextForceFieldShapeGroup_20_delegate getNextForceFieldShapeGroup_20_delegatefield;
		
		/// <summary>Creates a new variety index for force fields to access the scaling table, creates a new row in the scaling table. </summary>
		public virtual ushort createForceFieldVariety()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_createForceFieldVariety_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private ushort createForceFieldVariety_virtual()
		{
			return createForceFieldVariety();
		}
		
		delegate ushort createForceFieldVariety_21_delegate();
		
		
		
		
		
		
		private createForceFieldVariety_21_delegate createForceFieldVariety_21_delegatefield;
		
		/// <summary>Returns the highest allocated force field variety. </summary>
		public virtual ushort getHighestForceFieldVariety()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getHighestForceFieldVariety_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private ushort getHighestForceFieldVariety_virtual()
		{
			return getHighestForceFieldVariety();
		}
		
		delegate ushort getHighestForceFieldVariety_22_delegate();
		
		
		
		
		
		
		private getHighestForceFieldVariety_22_delegate getHighestForceFieldVariety_22_delegatefield;
		
		/// <summary>Releases a forcefield variety index and the related row in the scaling table. </summary>
		/// <param name="mat">The variery index to release.</param>
		public virtual void releaseForceFieldVariety(ushort var)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseForceFieldVariety_INVOKE(ClassPointer, doSetFunctionPointers, var);
		}
		
		private void releaseForceFieldVariety_virtual(ushort var)
		{
			releaseForceFieldVariety(var);
		}
		
		delegate void releaseForceFieldVariety_23_delegate(ushort var);
		
		
		
		
		
		
		private releaseForceFieldVariety_23_delegate releaseForceFieldVariety_23_delegatefield;
		
		/// <summary>Creates a new index for objects(actor, fluid, cloth, softbody) to access the scaling table, creates a new column in the scaling table. </summary>
		public virtual ushort createForceFieldMaterial()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_createForceFieldMaterial_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private ushort createForceFieldMaterial_virtual()
		{
			return createForceFieldMaterial();
		}
		
		delegate ushort createForceFieldMaterial_24_delegate();
		
		
		
		
		
		
		private createForceFieldMaterial_24_delegate createForceFieldMaterial_24_delegatefield;
		
		/// <summary>Returns the highest allocated force field material. </summary>
		public virtual ushort getHighestForceFieldMaterial()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getHighestForceFieldMaterial_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private ushort getHighestForceFieldMaterial_virtual()
		{
			return getHighestForceFieldMaterial();
		}
		
		delegate ushort getHighestForceFieldMaterial_25_delegate();
		
		
		
		
		
		
		private getHighestForceFieldMaterial_25_delegate getHighestForceFieldMaterial_25_delegatefield;
		
		/// <summary>Releases a forcefield material index and the related column in the scaling table. </summary>
		/// <param name="mat">The material index to release.</param>
		public virtual void releaseForceFieldMaterial(ushort mat)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseForceFieldMaterial_INVOKE(ClassPointer, doSetFunctionPointers, mat);
		}
		
		private void releaseForceFieldMaterial_virtual(ushort mat)
		{
			releaseForceFieldMaterial(mat);
		}
		
		delegate void releaseForceFieldMaterial_26_delegate(ushort mat);
		
		
		
		
		
		
		private releaseForceFieldMaterial_26_delegate releaseForceFieldMaterial_26_delegatefield;
		
		/// <summary>Get the scaling value for a given variety/material pair. </summary>
		public virtual float getForceFieldScale(ushort var, ushort mat)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getForceFieldScale_INVOKE(ClassPointer, doSetFunctionPointers, var, mat);
		}
		
		private float getForceFieldScale_virtual(ushort var, ushort mat)
		{
			return getForceFieldScale(var, mat);
		}
		
		delegate float getForceFieldScale_27_delegate(ushort var, ushort mat);
		
		
		
		
		
		
		private getForceFieldScale_27_delegate getForceFieldScale_27_delegatefield;
		
		/// <summary>Set the scaling value for a given variety/material pair. </summary>
		/// <param name="var">A Variety index. </param>
		/// <param name="mat">A Material index. </param>
		/// <param name="val">The value to set at the variety/material coordinate in the table. Setting the value to big or to low may cause invalid floats in the kernel output.</param>
		public virtual void setForceFieldScale(ushort var, ushort mat, float val)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setForceFieldScale_INVOKE(ClassPointer, doSetFunctionPointers, var, mat, val);
		}
		
		private void setForceFieldScale_virtual(ushort var, ushort mat, float val)
		{
			setForceFieldScale(var, mat, val);
		}
		
		delegate void setForceFieldScale_28_delegate(ushort var, ushort mat, float val);
		
		
		
		
		
		
		private setForceFieldScale_28_delegate setForceFieldScale_28_delegatefield;
		
		/// <summary>Creates a new NxMaterial. </summary>
		/// <param name="matDesc">The material desc to use to create a material. See NxMaterialDesc. </param>
		public virtual NxMaterial createMaterial(NxMaterialDesc matDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxMaterial.GetClass(NxScene_createMaterial_INVOKE(ClassPointer, doSetFunctionPointers, (matDesc!=null ? matDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createMaterial_virtual(IntPtr matDesc)
		{
			return createMaterial(NxMaterialDesc.GetClass(matDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createMaterial_29_delegate(IntPtr matDesc);
		
		
		
		
		
		
		private createMaterial_29_delegate createMaterial_29_delegatefield;
		
		/// <summary>Deletes the specified material. </summary>
		/// <param name="material">The material to release.</param>
		public virtual void releaseMaterial(NxMaterial material)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseMaterial_INVOKE(ClassPointer, doSetFunctionPointers, (material!=null ? material.ClassPointer : NullRef));
		}
		
		private void releaseMaterial_virtual(IntPtr material)
		{
			releaseMaterial(NxMaterial.GetClass(material));
		}
		
		delegate void releaseMaterial_30_delegate(IntPtr material);
		
		
		
		
		
		
		private releaseMaterial_30_delegate releaseMaterial_30_delegatefield;
		
		/// <summary>Creates a scene compartment. </summary>
		/// <param name="compDesc">The NxCompartment descriptor to use to create a compartment. </param>
		public virtual NxCompartment createCompartment(NxCompartmentDesc compDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxCompartment.GetClass(NxScene_createCompartment_INVOKE(ClassPointer, doSetFunctionPointers, (compDesc!=null ? compDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createCompartment_virtual(IntPtr compDesc)
		{
			return createCompartment(NxCompartmentDesc.GetClass(compDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createCompartment_31_delegate(IntPtr compDesc);
		
		
		
		
		
		
		private createCompartment_31_delegate createCompartment_31_delegatefield;
		
		/// <summary>Returns the number of compartments created in the scene. </summary>
		public virtual uint getNbCompartments()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbCompartments_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbCompartments_virtual()
		{
			return getNbCompartments();
		}
		
		delegate uint getNbCompartments_32_delegate();
		
		
		
		
		
		
		private getNbCompartments_32_delegate getNbCompartments_32_delegatefield;
		
		/// <summary>Writes the scene's array of NxCompartment pointers to a user buffer. </summary>
		/// <param name="userBuffer">The buffer to receive compartment pointers. </param>
		/// <param name="bufferSize">The number of compartment pointers which can be stored in the buffer. </param>
		/// <param name="usersIterator">Cookie used to continue iteration from the last position. </param>
		public virtual uint getCompartmentArray(DoxyBindArray<NxCompartment> userBuffer, uint bufferSize, ref uint usersIterator)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getCompartmentArray_INVOKE(ClassPointer, doSetFunctionPointers, userBuffer, bufferSize, ref usersIterator);
		}
		
		private uint getCompartmentArray_virtual(IntPtr[] userBuffer, uint bufferSize, [In()] [Out()] ref uint usersIterator)
		{
			return getCompartmentArray(userBuffer, bufferSize, ref usersIterator);
		}
		
		delegate uint getCompartmentArray_33_delegate(IntPtr[] userBuffer, uint bufferSize, [In()] [Out()] ref uint usersIterator);
		
		
		
		
		
		
		private getCompartmentArray_33_delegate getCompartmentArray_33_delegatefield;
		
		/// <summary>Sets the pair flags for the given pair of actors. </summary>
		/// <param name="actorA">Actor A </param>
		/// <param name="actorB">Actor B </param>
		/// <param name="nxContactPairFlag">New set of contact pair flags. See NxContactPairFlag</param>
		public virtual void setActorPairFlags(NxActor actorA, NxActor actorB, uint nxContactPairFlag)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setActorPairFlags_INVOKE(ClassPointer, doSetFunctionPointers, (actorA!=null ? actorA.ClassPointer : NullRef), (actorB!=null ? actorB.ClassPointer : NullRef), nxContactPairFlag);
		}
		
		private void setActorPairFlags_virtual(IntPtr actorA, IntPtr actorB, uint nxContactPairFlag)
		{
			setActorPairFlags(NxActor.GetClass(actorA), NxActor.GetClass(actorB), nxContactPairFlag);
		}
		
		delegate void setActorPairFlags_34_delegate(IntPtr actorA, IntPtr actorB, uint nxContactPairFlag);
		
		
		
		
		
		
		private setActorPairFlags_34_delegate setActorPairFlags_34_delegatefield;
		
		/// <summary>Retrieves the pair flags for the given pair of actors. </summary>
		/// <param name="actorA">Actor A </param>
		/// <param name="actorB">Actor B </param>
		public virtual uint getActorPairFlags(NxActor actorA, NxActor actorB)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getActorPairFlags_INVOKE(ClassPointer, doSetFunctionPointers, (actorA!=null ? actorA.ClassPointer : NullRef), (actorB!=null ? actorB.ClassPointer : NullRef));
		}
		
		private uint getActorPairFlags_virtual(IntPtr actorA, IntPtr actorB)
		{
			return getActorPairFlags(NxActor.GetClass(actorA), NxActor.GetClass(actorB));
		}
		
		delegate uint getActorPairFlags_35_delegate(IntPtr actorA, IntPtr actorB);
		
		
		
		
		
		
		private getActorPairFlags_35_delegate getActorPairFlags_35_delegatefield;
		
		/// <summary>Similar to setActorPairFlags(), but for a pair of shapes. </summary>
		/// <param name="shapeA">Shape A </param>
		/// <param name="shapeB">Shape B </param>
		/// <param name="nxContactPairFlag">New set of shape contact pair flags.</param>
		public virtual void setShapePairFlags(NxShape shapeA, NxShape shapeB, uint nxContactPairFlag)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setShapePairFlags_INVOKE(ClassPointer, doSetFunctionPointers, (shapeA!=null ? shapeA.ClassPointer : NullRef), (shapeB!=null ? shapeB.ClassPointer : NullRef), nxContactPairFlag);
		}
		
		private void setShapePairFlags_virtual(IntPtr shapeA, IntPtr shapeB, uint nxContactPairFlag)
		{
			setShapePairFlags(NxShape.GetClass(shapeA), NxShape.GetClass(shapeB), nxContactPairFlag);
		}
		
		delegate void setShapePairFlags_36_delegate(IntPtr shapeA, IntPtr shapeB, uint nxContactPairFlag);
		
		
		
		
		
		
		private setShapePairFlags_36_delegate setShapePairFlags_36_delegatefield;
		
		/// <summary>Similar to getActorPairFlags(), but for a pair of shapes. </summary>
		/// <param name="shapeA">Shape A </param>
		/// <param name="shapeB">SHape B </param>
		public virtual uint getShapePairFlags(NxShape shapeA, NxShape shapeB)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getShapePairFlags_INVOKE(ClassPointer, doSetFunctionPointers, (shapeA!=null ? shapeA.ClassPointer : NullRef), (shapeB!=null ? shapeB.ClassPointer : NullRef));
		}
		
		private uint getShapePairFlags_virtual(IntPtr shapeA, IntPtr shapeB)
		{
			return getShapePairFlags(NxShape.GetClass(shapeA), NxShape.GetClass(shapeB));
		}
		
		delegate uint getShapePairFlags_37_delegate(IntPtr shapeA, IntPtr shapeB);
		
		
		
		
		
		
		private getShapePairFlags_37_delegate getShapePairFlags_37_delegatefield;
		
		/// <summary>Returns the number of pairs for which pairFlags are defined. Note that this includes compartments. </summary>
		public virtual uint getNbPairs()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbPairs_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbPairs_virtual()
		{
			return getNbPairs();
		}
		
		delegate uint getNbPairs_38_delegate();
		
		
		
		
		
		
		private getNbPairs_38_delegate getNbPairs_38_delegatefield;
		
		/// <summary>Retrieves the pair flag data. </summary>
		/// <param name="userArray">Pointer to user array to receive pair flags. should be at least sizeof(NxPairFlag)*numPairs in size. </param>
		/// <param name="numPairs">Number of pairs the user buffer can hold. </param>
		public virtual uint getPairFlagArray(NxPairFlag userArray, uint numPairs)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getPairFlagArray_INVOKE(ClassPointer, doSetFunctionPointers, (userArray!=null ? userArray.ClassPointer : NullRef), numPairs);
		}
		
		private uint getPairFlagArray_virtual(IntPtr userArray, uint numPairs)
		{
			return getPairFlagArray(NxPairFlag.GetClass(userArray), numPairs);
		}
		
		delegate uint getPairFlagArray_39_delegate(IntPtr userArray, uint numPairs);
		
		
		
		
		
		
		private getPairFlagArray_39_delegate getPairFlagArray_39_delegatefield;
		
		/// <summary>Specifies if collision should be performed by a pair of shape groups. </summary>
		/// <param name="group1">First group. </param>
		/// <param name="group2">Second group. </param>
		/// <param name="enable">True to enable collision between the groups.</param>
		public virtual void setGroupCollisionFlag(ushort group1, ushort group2, bool enable)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setGroupCollisionFlag_INVOKE(ClassPointer, doSetFunctionPointers, group1, group2, enable);
		}
		
		private void setGroupCollisionFlag_virtual(ushort group1, ushort group2, bool enable)
		{
			setGroupCollisionFlag(group1, group2, enable);
		}
		
		delegate void setGroupCollisionFlag_40_delegate(ushort group1, ushort group2, bool enable);
		
		
		
		
		
		
		private setGroupCollisionFlag_40_delegate setGroupCollisionFlag_40_delegatefield;
		
		/// <summary>Determines if collision detection is performed between a pair of groups. </summary>
		/// <param name="group1">First Group. </param>
		/// <param name="group2">Second Group. </param>
		public virtual bool getGroupCollisionFlag(ushort group1, ushort group2)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getGroupCollisionFlag_INVOKE(ClassPointer, doSetFunctionPointers, group1, group2);
		}
		
		private bool getGroupCollisionFlag_virtual(ushort group1, ushort group2)
		{
			return getGroupCollisionFlag(group1, group2);
		}
		
		delegate bool getGroupCollisionFlag_41_delegate(ushort group1, ushort group2);
		
		
		
		
		
		
		private getGroupCollisionFlag_41_delegate getGroupCollisionFlag_41_delegatefield;
		
		/// <summary>Specifies the dominance behavior of constraints between two actors with two certain dominance groups. </summary>
		public virtual void setDominanceGroupPair(ushort group1, ushort group2, NxConstraintDominance dominance)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setDominanceGroupPair_INVOKE(ClassPointer, doSetFunctionPointers, group1, group2, (dominance!=null ? dominance.ClassPointer : NullRef));
		}
		
		private void setDominanceGroupPair_virtual(ushort group1, ushort group2, IntPtr dominance)
		{
			setDominanceGroupPair(group1, group2, NxConstraintDominance.GetClass(dominance));
		}
		
		delegate void setDominanceGroupPair_42_delegate(ushort group1, ushort group2, IntPtr dominance);
		
		
		
		
		
		
		private setDominanceGroupPair_42_delegate setDominanceGroupPair_42_delegatefield;
		
		/// <summary>Samples the dominance matrix. </summary>
		public virtual NxConstraintDominance getDominanceGroupPair(ushort group1, ushort group2)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxConstraintDominance.GetClass(NxScene_getDominanceGroupPair_INVOKE(ClassPointer, doSetFunctionPointers, group1, group2));
		}
		
		private IntPtr getDominanceGroupPair_virtual(ushort group1, ushort group2)
		{
			return getDominanceGroupPair(group1, group2).ClassPointer.Handle;
		}
		
		delegate IntPtr getDominanceGroupPair_43_delegate(ushort group1, ushort group2);
		
		
		
		
		
		
		private getDominanceGroupPair_43_delegate getDominanceGroupPair_43_delegatefield;
		
		/// <summary>With this method one can set contact reporting flags between actors belonging to a pair of groups. </summary>
		/// <param name="group1">First group. </param>
		/// <param name="group2">Second group </param>
		/// <param name="flags">Flags to control contact reporting. See NxContactPairFlag.</param>
		public virtual void setActorGroupPairFlags(ushort group1, ushort group2, uint flags)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setActorGroupPairFlags_INVOKE(ClassPointer, doSetFunctionPointers, group1, group2, flags);
		}
		
		private void setActorGroupPairFlags_virtual(ushort group1, ushort group2, uint flags)
		{
			setActorGroupPairFlags(group1, group2, flags);
		}
		
		delegate void setActorGroupPairFlags_44_delegate(ushort group1, ushort group2, uint flags);
		
		
		
		
		
		
		private setActorGroupPairFlags_44_delegate setActorGroupPairFlags_44_delegatefield;
		
		/// <summary>This reads the value set with setActorGroupPairFlags. </summary>
		/// <param name="group1">First Group </param>
		/// <param name="group2">Second Group </param>
		public virtual uint getActorGroupPairFlags(ushort group1, ushort group2)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getActorGroupPairFlags_INVOKE(ClassPointer, doSetFunctionPointers, group1, group2);
		}
		
		private uint getActorGroupPairFlags_virtual(ushort group1, ushort group2)
		{
			return getActorGroupPairFlags(group1, group2);
		}
		
		delegate uint getActorGroupPairFlags_45_delegate(ushort group1, ushort group2);
		
		
		
		
		
		
		private getActorGroupPairFlags_45_delegate getActorGroupPairFlags_45_delegatefield;
		
		/// <summary>Gets the number of actor group flags (as set by setActorGroupPairFlags). </summary>
		public virtual uint getNbActorGroupPairs()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbActorGroupPairs_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbActorGroupPairs_virtual()
		{
			return getNbActorGroupPairs();
		}
		
		delegate uint getNbActorGroupPairs_46_delegate();
		
		
		
		
		
		
		private getNbActorGroupPairs_46_delegate getNbActorGroupPairs_46_delegatefield;
		
		/// <summary>Writes the scene's array of actor group flags (as set by setActorGroupPairFlags) to a user buffer. </summary>
		/// <param name="userBuffer">The buffer to receive NxActorGroupPairs. </param>
		/// <param name="bufferSize">The number of NxActorGroupPairs which can be stored in the buffer. </param>
		/// <param name="userIterator">Cookie used to continue iteration from the last position. </param>
		public virtual uint getActorGroupPairArray(NxActorGroupPair userBuffer, uint bufferSize, ref uint userIterator)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getActorGroupPairArray_INVOKE(ClassPointer, doSetFunctionPointers, (userBuffer!=null ? userBuffer.ClassPointer : NullRef), bufferSize, ref userIterator);
		}
		
		private uint getActorGroupPairArray_virtual(IntPtr userBuffer, uint bufferSize, [In()] [Out()] ref uint userIterator)
		{
			return getActorGroupPairArray(NxActorGroupPair.GetClass(userBuffer), bufferSize, ref userIterator);
		}
		
		delegate uint getActorGroupPairArray_47_delegate(IntPtr userBuffer, uint bufferSize, [In()] [Out()] ref uint userIterator);
		
		
		
		
		
		
		private getActorGroupPairArray_47_delegate getActorGroupPairArray_47_delegatefield;
		
		/// <summary>Setups filtering operations. See comments for NxGroupsMask. </summary>
		/// <param name="op0">Filter op 0. </param>
		/// <param name="op1">Filter op 1. </param>
		/// <param name="op2">Filter op 2.</param>
		public virtual void setFilterOps(NxFilterOp op0, NxFilterOp op1, NxFilterOp op2)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setFilterOps_INVOKE(ClassPointer, doSetFunctionPointers, op0, op1, op2);
		}
		
		private void setFilterOps_virtual(NxFilterOp op0, NxFilterOp op1, NxFilterOp op2)
		{
			setFilterOps(op0, op1, op2);
		}
		
		delegate void setFilterOps_48_delegate(NxFilterOp op0, NxFilterOp op1, NxFilterOp op2);
		
		
		
		
		
		
		private setFilterOps_48_delegate setFilterOps_48_delegatefield;
		
		/// <summary>Setups filtering's boolean value. See comments for NxGroupsMask. </summary>
		/// <param name="flag">Boolean value for filter.</param>
		public virtual void setFilterBool(bool flag)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setFilterBool_INVOKE(ClassPointer, doSetFunctionPointers, flag);
		}
		
		private void setFilterBool_virtual(bool flag)
		{
			setFilterBool(flag);
		}
		
		delegate void setFilterBool_49_delegate(bool flag);
		
		
		
		
		
		
		private setFilterBool_49_delegate setFilterBool_49_delegatefield;
		
		/// <summary>Setups filtering's K0 value. See comments for NxGroupsMask. </summary>
		/// <param name="mask">The new group mask. See NxGroupsMask.</param>
		public virtual void setFilterConstant0(NxGroupsMask mask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setFilterConstant0_INVOKE(ClassPointer, doSetFunctionPointers, (mask!=null ? mask.ClassPointer : NullRef));
		}
		
		private void setFilterConstant0_virtual(IntPtr mask)
		{
			setFilterConstant0(NxGroupsMask.GetClass(mask));
		}
		
		delegate void setFilterConstant0_50_delegate(IntPtr mask);
		
		
		
		
		
		
		private setFilterConstant0_50_delegate setFilterConstant0_50_delegatefield;
		
		/// <summary>Setups filtering's K1 value. See comments for NxGroupsMask. </summary>
		/// <param name="mask">The new group mask. See NxGroupsMask.</param>
		public virtual void setFilterConstant1(NxGroupsMask mask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setFilterConstant1_INVOKE(ClassPointer, doSetFunctionPointers, (mask!=null ? mask.ClassPointer : NullRef));
		}
		
		private void setFilterConstant1_virtual(IntPtr mask)
		{
			setFilterConstant1(NxGroupsMask.GetClass(mask));
		}
		
		delegate void setFilterConstant1_51_delegate(IntPtr mask);
		
		
		
		
		
		
		private setFilterConstant1_51_delegate setFilterConstant1_51_delegatefield;
		
		/// <summary>Retrieves filtering operation. See comments for NxGroupsMask. </summary>
		/// <param name="op0">First filter operator. </param>
		/// <param name="op1">Second filter operator. </param>
		/// <param name="op2">Third filter operator.</param>
		public virtual void getFilterOps(ref NxFilterOp op0, ref NxFilterOp op1, ref NxFilterOp op2)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_getFilterOps_INVOKE(ClassPointer, doSetFunctionPointers, ref op0, ref op1, ref op2);
		}
		
		private void getFilterOps_virtual([In()] [Out()] ref NxFilterOp op0, [In()] [Out()] ref NxFilterOp op1, [In()] [Out()] ref NxFilterOp op2)
		{
			getFilterOps(ref op0, ref op1, ref op2);
		}
		
		delegate void getFilterOps_52_delegate([In()] [Out()] ref NxFilterOp op0, [In()] [Out()] ref NxFilterOp op1, [In()] [Out()] ref NxFilterOp op2);
		
		
		
		
		
		
		private getFilterOps_52_delegate getFilterOps_52_delegatefield;
		
		/// <summary>Retrieves filtering's boolean value. See comments for NxGroupsMask. </summary>
		public virtual bool getFilterBool()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getFilterBool_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private bool getFilterBool_virtual()
		{
			return getFilterBool();
		}
		
		delegate bool getFilterBool_53_delegate();
		
		
		
		
		
		
		private getFilterBool_53_delegate getFilterBool_53_delegatefield;
		
		/// <summary>Gets filtering constant K0. See comments for NxGroupsMask. </summary>
		public virtual NxGroupsMask getFilterConstant0()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxGroupsMask.GetClass(NxScene_getFilterConstant0_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getFilterConstant0_virtual()
		{
			return getFilterConstant0().ClassPointer.Handle;
		}
		
		delegate IntPtr getFilterConstant0_54_delegate();
		
		
		
		
		
		
		private getFilterConstant0_54_delegate getFilterConstant0_54_delegatefield;
		
		/// <summary>Gets filtering constant K1. See comments for NxGroupsMask. </summary>
		public virtual NxGroupsMask getFilterConstant1()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxGroupsMask.GetClass(NxScene_getFilterConstant1_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getFilterConstant1_virtual()
		{
			return getFilterConstant1().ClassPointer.Handle;
		}
		
		delegate IntPtr getFilterConstant1_55_delegate();
		
		
		
		
		
		
		private getFilterConstant1_55_delegate getFilterConstant1_55_delegatefield;
		
		/// <summary>Retrieve the number of actors in the scene. </summary>
		public virtual uint getNbActors()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbActors_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbActors_virtual()
		{
			return getNbActors();
		}
		
		delegate uint getNbActors_56_delegate();
		
		
		
		
		
		
		private getNbActors_56_delegate getNbActors_56_delegatefield;
		
		/// <summary>Retrieve an array of all the actors in the scene. </summary>
		public virtual DoxyBindArray<NxActor> getActors()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getActors_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private IntPtr[] getActors_virtual()
		{
			return getActors();
		}
		
		delegate IntPtr[] getActors_57_delegate();
		
		
		
		
		
		
		private getActors_57_delegate getActors_57_delegatefield;
		
		/// <summary>Queries the NxScene for a list of the NxActors whose transforms have been updated during the previous simulation step. </summary>
		/// <param name="nbTransformsOut">The number of transforms returned.</param>
		public virtual NxActiveTransform getActiveTransforms(ref uint nbTransformsOut)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxActiveTransform.GetClass(NxScene_getActiveTransforms_INVOKE(ClassPointer, doSetFunctionPointers, ref nbTransformsOut));
		}
		
		private IntPtr getActiveTransforms_virtual([In()] [Out()] ref uint nbTransformsOut)
		{
			return getActiveTransforms(ref nbTransformsOut).ClassPointer.Handle;
		}
		
		delegate IntPtr getActiveTransforms_58_delegate([In()] [Out()] ref uint nbTransformsOut);
		
		
		
		
		
		
		private getActiveTransforms_58_delegate getActiveTransforms_58_delegatefield;
		
		/// <summary>Returns the number of static shapes in the scene. Note that this includes compartments and mirrored shapes in compartments. </summary>
		public virtual uint getNbStaticShapes()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbStaticShapes_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbStaticShapes_virtual()
		{
			return getNbStaticShapes();
		}
		
		delegate uint getNbStaticShapes_59_delegate();
		
		
		
		
		
		
		private getNbStaticShapes_59_delegate getNbStaticShapes_59_delegatefield;
		
		/// <summary>Returns the number of dynamic shapes in the scene. Note that this includes compartments and mirrored shapes in compartments. </summary>
		public virtual uint getNbDynamicShapes()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbDynamicShapes_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbDynamicShapes_virtual()
		{
			return getNbDynamicShapes();
		}
		
		delegate uint getNbDynamicShapes_60_delegate();
		
		
		
		
		
		
		private getNbDynamicShapes_60_delegate getNbDynamicShapes_60_delegatefield;
		
		/// <summary>Returns the total number of shapes in the scene, including compounds' sub-shapes. Note that this also includes compartments and mirrored shapes in compartments. </summary>
		public virtual uint getTotalNbShapes()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getTotalNbShapes_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getTotalNbShapes_virtual()
		{
			return getTotalNbShapes();
		}
		
		delegate uint getTotalNbShapes_61_delegate();
		
		
		
		
		
		
		private getTotalNbShapes_61_delegate getTotalNbShapes_61_delegatefield;
		
		/// <summary>Returns the number of joints in the scene (excluding "dead" joints). Note that this includes compartments. </summary>
		public virtual uint getNbJoints()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbJoints_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbJoints_virtual()
		{
			return getNbJoints();
		}
		
		delegate uint getNbJoints_62_delegate();
		
		
		
		
		
		
		private getNbJoints_62_delegate getNbJoints_62_delegatefield;
		
		/// <summary>Restarts the joint iterator so that the next call to getNextJoint() returns the first joint in the scene. </summary>
		public virtual void resetJointIterator()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_resetJointIterator_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void resetJointIterator_virtual()
		{
			resetJointIterator();
		}
		
		delegate void resetJointIterator_63_delegate();
		
		
		
		
		
		
		private resetJointIterator_63_delegate resetJointIterator_63_delegatefield;
		
		/// <summary>Retrieves the next joint when iterating. </summary>
		public virtual NxJoint getNextJoint()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxJoint.GetClass(NxScene_getNextJoint_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getNextJoint_virtual()
		{
			return getNextJoint().ClassPointer.Handle;
		}
		
		delegate IntPtr getNextJoint_64_delegate();
		
		
		
		
		
		
		private getNextJoint_64_delegate getNextJoint_64_delegatefield;
		
		/// <summary>Returns the number of effectors in the scene. </summary>
		public virtual uint getNbEffectors()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbEffectors_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbEffectors_virtual()
		{
			return getNbEffectors();
		}
		
		delegate uint getNbEffectors_65_delegate();
		
		
		
		
		
		
		private getNbEffectors_65_delegate getNbEffectors_65_delegatefield;
		
		/// <summary>Restarts the effector iterator so that the next call to getNextEffector() returns the first effector in the scene. </summary>
		public virtual void resetEffectorIterator()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_resetEffectorIterator_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void resetEffectorIterator_virtual()
		{
			resetEffectorIterator();
		}
		
		delegate void resetEffectorIterator_66_delegate();
		
		
		
		
		
		
		private resetEffectorIterator_66_delegate resetEffectorIterator_66_delegatefield;
		
		/// <summary>Retrieves the next effector when iterating through the effectors in the scene. </summary>
		public virtual NxEffector getNextEffector()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxEffector.GetClass(NxScene_getNextEffector_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getNextEffector_virtual()
		{
			return getNextEffector().ClassPointer.Handle;
		}
		
		delegate IntPtr getNextEffector_67_delegate();
		
		
		
		
		
		
		private getNextEffector_67_delegate getNextEffector_67_delegatefield;
		
		/// <summary>Returns an upper bound for the number of actors in the collision island of a certain actor. </summary>
		/// <param name="actor">The actor for which to return island information</param>
		public virtual uint getBoundForIslandSize(NxActor actor)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getBoundForIslandSize_INVOKE(ClassPointer, doSetFunctionPointers, (actor!=null ? actor.ClassPointer : NullRef));
		}
		
		private uint getBoundForIslandSize_virtual(IntPtr actor)
		{
			return getBoundForIslandSize(NxActor.GetClass(actor));
		}
		
		delegate uint getBoundForIslandSize_68_delegate(IntPtr actor);
		
		
		
		
		
		
		private getBoundForIslandSize_68_delegate getBoundForIslandSize_68_delegatefield;
		
		/// <summary>Writes pointers to the actors making up the collision island of a certain actor to a user buffer. </summary>
		/// <param name="actor">The actor for which to return island information </param>
		/// <param name="userBuffer">The buffer to receive actor pointers. </param>
		/// <param name="bufferSize">The number of actor pointers which can be stored in the buffer. </param>
		/// <param name="userIterator">Cookie used to continue iteration from the last position. </param>
		public virtual uint getIslandArrayFromActor(NxActor actor, DoxyBindArray<NxActor> userBuffer, uint bufferSize, ref uint userIterator)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getIslandArrayFromActor_INVOKE(ClassPointer, doSetFunctionPointers, (actor!=null ? actor.ClassPointer : NullRef), userBuffer, bufferSize, ref userIterator);
		}
		
		private uint getIslandArrayFromActor_virtual(IntPtr actor, IntPtr[] userBuffer, uint bufferSize, [In()] [Out()] ref uint userIterator)
		{
			return getIslandArrayFromActor(NxActor.GetClass(actor), userBuffer, bufferSize, ref userIterator);
		}
		
		delegate uint getIslandArrayFromActor_69_delegate(IntPtr actor, IntPtr[] userBuffer, uint bufferSize, [In()] [Out()] ref uint userIterator);
		
		
		
		
		
		
		private getIslandArrayFromActor_69_delegate getIslandArrayFromActor_69_delegatefield;
		
		/// <summary>Return the number of materials in the scene. </summary>
		public virtual uint getNbMaterials()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbMaterials_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbMaterials_virtual()
		{
			return getNbMaterials();
		}
		
		delegate uint getNbMaterials_70_delegate();
		
		
		
		
		
		
		private getNbMaterials_70_delegate getNbMaterials_70_delegatefield;
		
		/// <summary>Writes the scene's array of material pointers to a user buffer. </summary>
		/// <param name="userBuffer">The buffer to receive material pointers. </param>
		/// <param name="bufferSize">The number of material pointers which can be stored in the buffer. </param>
		/// <param name="usersIterator">Cookie used to continue iteration from the last position. </param>
		public virtual uint getMaterialArray(DoxyBindArray<NxMaterial> userBuffer, uint bufferSize, ref uint usersIterator)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getMaterialArray_INVOKE(ClassPointer, doSetFunctionPointers, userBuffer, bufferSize, ref usersIterator);
		}
		
		private uint getMaterialArray_virtual(IntPtr[] userBuffer, uint bufferSize, [In()] [Out()] ref uint usersIterator)
		{
			return getMaterialArray(userBuffer, bufferSize, ref usersIterator);
		}
		
		delegate uint getMaterialArray_71_delegate(IntPtr[] userBuffer, uint bufferSize, [In()] [Out()] ref uint usersIterator);
		
		
		
		
		
		
		private getMaterialArray_71_delegate getMaterialArray_71_delegatefield;
		
		/// <summary>Returns current highest valid material index. </summary>
		public virtual ushort getHighestMaterialIndex()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getHighestMaterialIndex_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private ushort getHighestMaterialIndex_virtual()
		{
			return getHighestMaterialIndex();
		}
		
		delegate ushort getHighestMaterialIndex_72_delegate();
		
		
		
		
		
		
		private getHighestMaterialIndex_72_delegate getHighestMaterialIndex_72_delegatefield;
		
		/// <summary>Retrieves the material with the given material index. </summary>
		/// <param name="matIndex">Material index to retrieve. </param>
		public virtual NxMaterial getMaterialFromIndex(ushort matIndex)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxMaterial.GetClass(NxScene_getMaterialFromIndex_INVOKE(ClassPointer, doSetFunctionPointers, matIndex));
		}
		
		private IntPtr getMaterialFromIndex_virtual(ushort matIndex)
		{
			return getMaterialFromIndex(matIndex).ClassPointer.Handle;
		}
		
		delegate IntPtr getMaterialFromIndex_73_delegate(ushort matIndex);
		
		
		
		
		
		
		private getMaterialFromIndex_73_delegate getMaterialFromIndex_73_delegatefield;
		
		/// <summary>Sets a user notify object which receives special simulation events when they occur. </summary>
		/// <param name="callback">User notification callback. See NxUserNotify.</param>
		public virtual void setUserNotify(NxUserNotify callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setUserNotify_INVOKE(ClassPointer, doSetFunctionPointers, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private void setUserNotify_virtual(IntPtr callback)
		{
			setUserNotify(NxUserNotify.GetClass(callback));
		}
		
		delegate void setUserNotify_74_delegate(IntPtr callback);
		
		
		
		
		
		
		private setUserNotify_74_delegate setUserNotify_74_delegatefield;
		
		/// <summary>Retrieves the userNotify pointer set with setUserNotify(). </summary>
		public virtual NxUserNotify getUserNotify()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxUserNotify.GetClass(NxScene_getUserNotify_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getUserNotify_virtual()
		{
			return getUserNotify().ClassPointer.Handle;
		}
		
		delegate IntPtr getUserNotify_75_delegate();
		
		
		
		
		
		
		private getUserNotify_75_delegate getUserNotify_75_delegatefield;
		
		/// <summary>Sets a user notify object which receives special simulation events when they occur. </summary>
		/// <param name="callback">User fluid notification callback. See NxFluidUserNotify.</param>
		public virtual void setFluidUserNotify(NxFluidUserNotify callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setFluidUserNotify_INVOKE(ClassPointer, doSetFunctionPointers, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private void setFluidUserNotify_virtual(IntPtr callback)
		{
			setFluidUserNotify(NxFluidUserNotify.GetClass(callback));
		}
		
		delegate void setFluidUserNotify_76_delegate(IntPtr callback);
		
		
		
		
		
		
		private setFluidUserNotify_76_delegate setFluidUserNotify_76_delegatefield;
		
		/// <summary>Retrieves the NxFluidUserNotify pointer set with setfluidUserNotify(). </summary>
		public virtual NxFluidUserNotify getFluidUserNotify()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxFluidUserNotify.GetClass(NxScene_getFluidUserNotify_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getFluidUserNotify_virtual()
		{
			return getFluidUserNotify().ClassPointer.Handle;
		}
		
		delegate IntPtr getFluidUserNotify_77_delegate();
		
		
		
		
		
		
		private getFluidUserNotify_77_delegate getFluidUserNotify_77_delegatefield;
		
		/// <summary>Sets a user notify object which receives special simulation events when they occur. </summary>
		/// <param name="callback">User cloth notification callback. See NxClothUserNotify.</param>
		public virtual void setClothUserNotify(NxClothUserNotify callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setClothUserNotify_INVOKE(ClassPointer, doSetFunctionPointers, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private void setClothUserNotify_virtual(IntPtr callback)
		{
			setClothUserNotify(NxClothUserNotify.GetClass(callback));
		}
		
		delegate void setClothUserNotify_78_delegate(IntPtr callback);
		
		
		
		
		
		
		private setClothUserNotify_78_delegate setClothUserNotify_78_delegatefield;
		
		/// <summary>Retrieves the NxClothUserNotify pointer set with setClothUserNotify(). </summary>
		public virtual NxClothUserNotify getClothUserNotify()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxClothUserNotify.GetClass(NxScene_getClothUserNotify_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getClothUserNotify_virtual()
		{
			return getClothUserNotify().ClassPointer.Handle;
		}
		
		delegate IntPtr getClothUserNotify_79_delegate();
		
		
		
		
		
		
		private getClothUserNotify_79_delegate getClothUserNotify_79_delegatefield;
		
		/// <summary>Sets a user notify object which receives special simulation events when they occur. </summary>
		/// <param name="callback">User softbody notification callback. See NxSoftBodyUserNotify.</param>
		public virtual void setSoftBodyUserNotify(NxSoftBodyUserNotify callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setSoftBodyUserNotify_INVOKE(ClassPointer, doSetFunctionPointers, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private void setSoftBodyUserNotify_virtual(IntPtr callback)
		{
			setSoftBodyUserNotify(NxSoftBodyUserNotify.GetClass(callback));
		}
		
		delegate void setSoftBodyUserNotify_80_delegate(IntPtr callback);
		
		
		
		
		
		
		private setSoftBodyUserNotify_80_delegate setSoftBodyUserNotify_80_delegatefield;
		
		/// <summary>Retrieves the NxSoftBodyUserNotify pointer set with setSoftBodyUserNotify(). </summary>
		public virtual NxSoftBodyUserNotify getSoftBodyUserNotify()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxSoftBodyUserNotify.GetClass(NxScene_getSoftBodyUserNotify_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getSoftBodyUserNotify_virtual()
		{
			return getSoftBodyUserNotify().ClassPointer.Handle;
		}
		
		delegate IntPtr getSoftBodyUserNotify_81_delegate();
		
		
		
		
		
		
		private getSoftBodyUserNotify_81_delegate getSoftBodyUserNotify_81_delegatefield;
		
		/// <summary>Sets a user callback object, which receives callbacks on all contacts generated for specified actors. </summary>
		/// <param name="callback">Asynchronous user contact modification callback. See NxUserContactModify.</param>
		public virtual void setUserContactModify(NxUserContactModify callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setUserContactModify_INVOKE(ClassPointer, doSetFunctionPointers, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private void setUserContactModify_virtual(IntPtr callback)
		{
			setUserContactModify(NxUserContactModify.GetClass(callback));
		}
		
		delegate void setUserContactModify_82_delegate(IntPtr callback);
		
		
		
		
		
		
		private setUserContactModify_82_delegate setUserContactModify_82_delegatefield;
		
		/// <summary>Retrieves the NxUserContactModify pointer set with setUserContactModify(). </summary>
		public virtual NxUserContactModify getUserContactModify()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxUserContactModify.GetClass(NxScene_getUserContactModify_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getUserContactModify_virtual()
		{
			return getUserContactModify().ClassPointer.Handle;
		}
		
		delegate IntPtr getUserContactModify_83_delegate();
		
		
		
		
		
		
		private getUserContactModify_83_delegate getUserContactModify_83_delegatefield;
		
		/// <summary>Sets a trigger report object which receives collision trigger events. </summary>
		/// <param name="callback">User trigger callback. See NxUserTriggerReport.</param>
		public virtual void setUserTriggerReport(NxUserTriggerReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setUserTriggerReport_INVOKE(ClassPointer, doSetFunctionPointers, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private void setUserTriggerReport_virtual(IntPtr callback)
		{
			setUserTriggerReport(NxUserTriggerReport.GetClass(callback));
		}
		
		delegate void setUserTriggerReport_84_delegate(IntPtr callback);
		
		
		
		
		
		
		private setUserTriggerReport_84_delegate setUserTriggerReport_84_delegatefield;
		
		/// <summary>Retrieves the callback pointer set with setUserTriggerReport(). </summary>
		public virtual NxUserTriggerReport getUserTriggerReport()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxUserTriggerReport.GetClass(NxScene_getUserTriggerReport_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getUserTriggerReport_virtual()
		{
			return getUserTriggerReport().ClassPointer.Handle;
		}
		
		delegate IntPtr getUserTriggerReport_85_delegate();
		
		
		
		
		
		
		private getUserTriggerReport_85_delegate getUserTriggerReport_85_delegatefield;
		
		/// <summary>Sets a contact report object which receives collision contact events. </summary>
		/// <param name="callback">User contact callback. See NxUserContactReport.</param>
		public virtual void setUserContactReport(NxUserContactReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setUserContactReport_INVOKE(ClassPointer, doSetFunctionPointers, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private void setUserContactReport_virtual(IntPtr callback)
		{
			setUserContactReport(NxUserContactReport.GetClass(callback));
		}
		
		delegate void setUserContactReport_86_delegate(IntPtr callback);
		
		
		
		
		
		
		private setUserContactReport_86_delegate setUserContactReport_86_delegatefield;
		
		/// <summary>Retrieves the callback pointer set with setUserContactReport(). </summary>
		public virtual NxUserContactReport getUserContactReport()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxUserContactReport.GetClass(NxScene_getUserContactReport_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getUserContactReport_virtual()
		{
			return getUserContactReport().ClassPointer.Handle;
		}
		
		delegate IntPtr getUserContactReport_87_delegate();
		
		
		
		
		
		
		private getUserContactReport_87_delegate getUserContactReport_87_delegatefield;
		
		/// <summary>Sets the custom actor pair filtering to use for this scene. </summary>
		/// <param name="callback">Filtering class that defines the callback to use for custom pair filtering.</param>
		public virtual void setUserActorPairFiltering(NxUserActorPairFiltering callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setUserActorPairFiltering_INVOKE(ClassPointer, doSetFunctionPointers, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private void setUserActorPairFiltering_virtual(IntPtr callback)
		{
			setUserActorPairFiltering(NxUserActorPairFiltering.GetClass(callback));
		}
		
		delegate void setUserActorPairFiltering_88_delegate(IntPtr callback);
		
		
		
		
		
		
		private setUserActorPairFiltering_88_delegate setUserActorPairFiltering_88_delegatefield;
		
		/// <summary>Gets the custom actor pair filtering in use for this scene. </summary>
		public virtual NxUserActorPairFiltering getUserActorPairFiltering()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxUserActorPairFiltering.GetClass(NxScene_getUserActorPairFiltering_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getUserActorPairFiltering_virtual()
		{
			return getUserActorPairFiltering().ClassPointer.Handle;
		}
		
		delegate IntPtr getUserActorPairFiltering_89_delegate();
		
		
		
		
		
		
		private getUserActorPairFiltering_89_delegate getUserActorPairFiltering_89_delegatefield;
		
		/// <summary>Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting bounds. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool raycastAnyBounds(NxRay worldRay, NxShapesType shapesType, uint groups, float maxDist, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyBounds_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType, groups, maxDist, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private bool raycastAnyBounds_virtual(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist, IntPtr groupsMask)
		{
			return raycastAnyBounds(NxRay.GetClass(worldRay), shapesType, groups, maxDist, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate bool raycastAnyBounds_90_delegate(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist, IntPtr groupsMask);
		
		
		
		
		
		
		private raycastAnyBounds_90_delegate raycastAnyBounds_90_delegatefield;
		
		/// <summary>Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting bounds. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool raycastAnyBounds(NxRay worldRay, NxShapesType shapesType, uint groups, float maxDist)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyBounds_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType, groups, maxDist);
		}
		
		private bool raycastAnyBounds_virtual(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist)
		{
			return raycastAnyBounds(NxRay.GetClass(worldRay), shapesType, groups, maxDist);
		}
		
		delegate bool raycastAnyBounds_91_delegate(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist);
		
		
		
		
		
		
		private raycastAnyBounds_91_delegate raycastAnyBounds_91_delegatefield;
		
		/// <summary>Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting bounds. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool raycastAnyBounds(NxRay worldRay, NxShapesType shapesType, uint groups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyBounds_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType, groups);
		}
		
		private bool raycastAnyBounds_virtual(IntPtr worldRay, NxShapesType shapesType, uint groups)
		{
			return raycastAnyBounds(NxRay.GetClass(worldRay), shapesType, groups);
		}
		
		delegate bool raycastAnyBounds_92_delegate(IntPtr worldRay, NxShapesType shapesType, uint groups);
		
		
		
		
		
		
		private raycastAnyBounds_92_delegate raycastAnyBounds_92_delegatefield;
		
		/// <summary>Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting bounds. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool raycastAnyBounds(NxRay worldRay, NxShapesType shapesType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyBounds_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType);
		}
		
		private bool raycastAnyBounds_virtual(IntPtr worldRay, NxShapesType shapesType)
		{
			return raycastAnyBounds(NxRay.GetClass(worldRay), shapesType);
		}
		
		delegate bool raycastAnyBounds_93_delegate(IntPtr worldRay, NxShapesType shapesType);
		
		
		
		
		
		
		private raycastAnyBounds_93_delegate raycastAnyBounds_93_delegatefield;
		
		/// <summary>Returns true if any shape of type ShapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual bool raycastAnyShape(NxRay worldRay, NxShapesType shapesType, uint groups, float maxDist, NxGroupsMask groupsMask, DoxyBindArray<NxShape> cache)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyShape_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType, groups, maxDist, (groupsMask!=null ? groupsMask.ClassPointer : NullRef), cache);
		}
		
		private bool raycastAnyShape_virtual(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist, IntPtr groupsMask, IntPtr[] cache)
		{
			return raycastAnyShape(NxRay.GetClass(worldRay), shapesType, groups, maxDist, NxGroupsMask.GetClass(groupsMask), cache);
		}
		
		delegate bool raycastAnyShape_94_delegate(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist, IntPtr groupsMask, IntPtr[] cache);
		
		
		
		
		
		
		private raycastAnyShape_94_delegate raycastAnyShape_94_delegatefield;
		
		/// <summary>Returns true if any shape of type ShapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual bool raycastAnyShape(NxRay worldRay, NxShapesType shapesType, uint groups, float maxDist, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyShape_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType, groups, maxDist, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private bool raycastAnyShape_virtual(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist, IntPtr groupsMask)
		{
			return raycastAnyShape(NxRay.GetClass(worldRay), shapesType, groups, maxDist, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate bool raycastAnyShape_95_delegate(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist, IntPtr groupsMask);
		
		
		
		
		
		
		private raycastAnyShape_95_delegate raycastAnyShape_95_delegatefield;
		
		/// <summary>Returns true if any shape of type ShapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual bool raycastAnyShape(NxRay worldRay, NxShapesType shapesType, uint groups, float maxDist)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyShape_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType, groups, maxDist);
		}
		
		private bool raycastAnyShape_virtual(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist)
		{
			return raycastAnyShape(NxRay.GetClass(worldRay), shapesType, groups, maxDist);
		}
		
		delegate bool raycastAnyShape_96_delegate(IntPtr worldRay, NxShapesType shapesType, uint groups, float maxDist);
		
		
		
		
		
		
		private raycastAnyShape_96_delegate raycastAnyShape_96_delegatefield;
		
		/// <summary>Returns true if any shape of type ShapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual bool raycastAnyShape(NxRay worldRay, NxShapesType shapesType, uint groups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyShape_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType, groups);
		}
		
		private bool raycastAnyShape_virtual(IntPtr worldRay, NxShapesType shapesType, uint groups)
		{
			return raycastAnyShape(NxRay.GetClass(worldRay), shapesType, groups);
		}
		
		delegate bool raycastAnyShape_97_delegate(IntPtr worldRay, NxShapesType shapesType, uint groups);
		
		
		
		
		
		
		private raycastAnyShape_97_delegate raycastAnyShape_97_delegatefield;
		
		/// <summary>Returns true if any shape of type ShapeType is intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual bool raycastAnyShape(NxRay worldRay, NxShapesType shapesType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAnyShape_4_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapesType);
		}
		
		private bool raycastAnyShape_virtual(IntPtr worldRay, NxShapesType shapesType)
		{
			return raycastAnyShape(NxRay.GetClass(worldRay), shapesType);
		}
		
		delegate bool raycastAnyShape_98_delegate(IntPtr worldRay, NxShapesType shapesType);
		
		
		
		
		
		
		private raycastAnyShape_98_delegate raycastAnyShape_98_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the axis aligned bounding boxes enclosing shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllBounds(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllBounds_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType, groups, maxDist, hintFlags, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint raycastAllBounds_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask)
		{
			return raycastAllBounds(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType, groups, maxDist, hintFlags, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint raycastAllBounds_99_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask);
		
		
		
		
		
		
		private raycastAllBounds_99_delegate raycastAllBounds_99_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the axis aligned bounding boxes enclosing shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllBounds(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllBounds_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType, groups, maxDist, hintFlags);
		}
		
		private uint raycastAllBounds_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags)
		{
			return raycastAllBounds(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType, groups, maxDist, hintFlags);
		}
		
		delegate uint raycastAllBounds_100_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags);
		
		
		
		
		
		
		private raycastAllBounds_100_delegate raycastAllBounds_100_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the axis aligned bounding boxes enclosing shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllBounds(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType, uint groups, float maxDist)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllBounds_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType, groups, maxDist);
		}
		
		private uint raycastAllBounds_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist)
		{
			return raycastAllBounds(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType, groups, maxDist);
		}
		
		delegate uint raycastAllBounds_101_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist);
		
		
		
		
		
		
		private raycastAllBounds_101_delegate raycastAllBounds_101_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the axis aligned bounding boxes enclosing shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllBounds(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType, uint groups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllBounds_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType, groups);
		}
		
		private uint raycastAllBounds_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups)
		{
			return raycastAllBounds(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType, groups);
		}
		
		delegate uint raycastAllBounds_102_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups);
		
		
		
		
		
		
		private raycastAllBounds_102_delegate raycastAllBounds_102_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the axis aligned bounding boxes enclosing shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllBounds(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllBounds_4_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType);
		}
		
		private uint raycastAllBounds_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType)
		{
			return raycastAllBounds(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType);
		}
		
		delegate uint raycastAllBounds_103_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType);
		
		
		
		
		
		
		private raycastAllBounds_103_delegate raycastAllBounds_103_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllShapes(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllShapes_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType, groups, maxDist, hintFlags, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint raycastAllShapes_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask)
		{
			return raycastAllShapes(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType, groups, maxDist, hintFlags, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint raycastAllShapes_104_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask);
		
		
		
		
		
		
		private raycastAllShapes_104_delegate raycastAllShapes_104_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllShapes(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllShapes_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType, groups, maxDist, hintFlags);
		}
		
		private uint raycastAllShapes_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags)
		{
			return raycastAllShapes(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType, groups, maxDist, hintFlags);
		}
		
		delegate uint raycastAllShapes_105_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist, uint hintFlags);
		
		
		
		
		
		
		private raycastAllShapes_105_delegate raycastAllShapes_105_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllShapes(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType, uint groups, float maxDist)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllShapes_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType, groups, maxDist);
		}
		
		private uint raycastAllShapes_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist)
		{
			return raycastAllShapes(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType, groups, maxDist);
		}
		
		delegate uint raycastAllShapes_106_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups, float maxDist);
		
		
		
		
		
		
		private raycastAllShapes_106_delegate raycastAllShapes_106_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllShapes(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType, uint groups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllShapes_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType, groups);
		}
		
		private uint raycastAllShapes_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups)
		{
			return raycastAllShapes(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType, groups);
		}
		
		delegate uint raycastAllShapes_107_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType, uint groups);
		
		
		
		
		
		
		private raycastAllShapes_107_delegate raycastAllShapes_107_delegatefield;
		
		/// <summary>Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="report">User callback, to be called when an intersection is encountered. </param>
		/// <param name="shapesType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint raycastAllShapes(NxRay worldRay, NxUserRaycastReport report, NxShapesType shapesType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_raycastAllShapes_4_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), (report!=null ? report.ClassPointer : NullRef), shapesType);
		}
		
		private uint raycastAllShapes_virtual(IntPtr worldRay, IntPtr report, NxShapesType shapesType)
		{
			return raycastAllShapes(NxRay.GetClass(worldRay), NxUserRaycastReport.GetClass(report), shapesType);
		}
		
		delegate uint raycastAllShapes_108_delegate(IntPtr worldRay, IntPtr report, NxShapesType shapesType);
		
		
		
		
		
		
		private raycastAllShapes_108_delegate raycastAllShapes_108_delegatefield;
		
		/// <summary>Returns the first axis aligned bounding box enclosing a shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual NxShape raycastClosestBounds(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups, float maxDist, uint hintFlags, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestBounds_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups, maxDist, hintFlags, (groupsMask!=null ? groupsMask.ClassPointer : NullRef)));
		}
		
		private IntPtr raycastClosestBounds_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask)
		{
			return raycastClosestBounds(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups, maxDist, hintFlags, NxGroupsMask.GetClass(groupsMask)).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestBounds_109_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask);
		
		
		
		
		
		
		private raycastClosestBounds_109_delegate raycastClosestBounds_109_delegatefield;
		
		/// <summary>Returns the first axis aligned bounding box enclosing a shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual NxShape raycastClosestBounds(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups, float maxDist, uint hintFlags)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestBounds_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups, maxDist, hintFlags));
		}
		
		private IntPtr raycastClosestBounds_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags)
		{
			return raycastClosestBounds(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups, maxDist, hintFlags).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestBounds_110_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags);
		
		
		
		
		
		
		private raycastClosestBounds_110_delegate raycastClosestBounds_110_delegatefield;
		
		/// <summary>Returns the first axis aligned bounding box enclosing a shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual NxShape raycastClosestBounds(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups, float maxDist)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestBounds_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups, maxDist));
		}
		
		private IntPtr raycastClosestBounds_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist)
		{
			return raycastClosestBounds(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups, maxDist).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestBounds_111_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist);
		
		
		
		
		
		
		private raycastClosestBounds_111_delegate raycastClosestBounds_111_delegatefield;
		
		/// <summary>Returns the first axis aligned bounding box enclosing a shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual NxShape raycastClosestBounds(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestBounds_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups));
		}
		
		private IntPtr raycastClosestBounds_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups)
		{
			return raycastClosestBounds(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestBounds_112_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups);
		
		
		
		
		
		
		private raycastClosestBounds_112_delegate raycastClosestBounds_112_delegatefield;
		
		/// <summary>Returns the first axis aligned bounding box enclosing a shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual NxShape raycastClosestBounds(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestBounds_4_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef)));
		}
		
		private IntPtr raycastClosestBounds_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit)
		{
			return raycastClosestBounds(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit)).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestBounds_113_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit);
		
		
		
		
		
		
		private raycastClosestBounds_113_delegate raycastClosestBounds_113_delegatefield;
		
		/// <summary>Returns the first shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual NxShape raycastClosestShape(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups, float maxDist, uint hintFlags, NxGroupsMask groupsMask, DoxyBindArray<NxShape> cache)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestShape_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups, maxDist, hintFlags, (groupsMask!=null ? groupsMask.ClassPointer : NullRef), cache));
		}
		
		private IntPtr raycastClosestShape_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask, IntPtr[] cache)
		{
			return raycastClosestShape(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups, maxDist, hintFlags, NxGroupsMask.GetClass(groupsMask), cache).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestShape_114_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask, IntPtr[] cache);
		
		
		
		
		
		
		private raycastClosestShape_114_delegate raycastClosestShape_114_delegatefield;
		
		/// <summary>Returns the first shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual NxShape raycastClosestShape(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups, float maxDist, uint hintFlags, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestShape_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups, maxDist, hintFlags, (groupsMask!=null ? groupsMask.ClassPointer : NullRef)));
		}
		
		private IntPtr raycastClosestShape_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask)
		{
			return raycastClosestShape(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups, maxDist, hintFlags, NxGroupsMask.GetClass(groupsMask)).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestShape_115_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags, IntPtr groupsMask);
		
		
		
		
		
		
		private raycastClosestShape_115_delegate raycastClosestShape_115_delegatefield;
		
		/// <summary>Returns the first shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual NxShape raycastClosestShape(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups, float maxDist, uint hintFlags)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestShape_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups, maxDist, hintFlags));
		}
		
		private IntPtr raycastClosestShape_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags)
		{
			return raycastClosestShape(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups, maxDist, hintFlags).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestShape_116_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist, uint hintFlags);
		
		
		
		
		
		
		private raycastClosestShape_116_delegate raycastClosestShape_116_delegatefield;
		
		/// <summary>Returns the first shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual NxShape raycastClosestShape(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups, float maxDist)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestShape_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups, maxDist));
		}
		
		private IntPtr raycastClosestShape_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist)
		{
			return raycastClosestShape(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups, maxDist).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestShape_117_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups, float maxDist);
		
		
		
		
		
		
		private raycastClosestShape_117_delegate raycastClosestShape_117_delegatefield;
		
		/// <summary>Returns the first shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual NxShape raycastClosestShape(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit, uint groups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestShape_4_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef), groups));
		}
		
		private IntPtr raycastClosestShape_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups)
		{
			return raycastClosestShape(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit), groups).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestShape_118_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit, uint groups);
		
		
		
		
		
		
		private raycastClosestShape_118_delegate raycastClosestShape_118_delegatefield;
		
		/// <summary>Returns the first shape of type shapeType that is hit along the ray. </summary>
		/// <param name="worldRay">The ray to cast in the global frame. Range: See NxRay</param>
		/// <param name="shapeType">Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="hit">Description of the intersection. See NxRaycastHit. </param>
		/// <param name="groups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="maxDist">Max distance to check along the ray for intersecting objects. Range: (0,inf) </param>
		/// <param name="hintFlags">Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="cache">Possible cache for persistent raycasts, filled out by the SDK.</param>
		public virtual NxShape raycastClosestShape(NxRay worldRay, NxShapesType shapeType, NxRaycastHit hit)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxShape.GetClass(NxScene_raycastClosestShape_5_INVOKE(ClassPointer, doSetFunctionPointers, (worldRay!=null ? worldRay.ClassPointer : NullRef), shapeType, (hit!=null ? hit.ClassPointer : NullRef)));
		}
		
		private IntPtr raycastClosestShape_virtual(IntPtr worldRay, NxShapesType shapeType, IntPtr hit)
		{
			return raycastClosestShape(NxRay.GetClass(worldRay), shapeType, NxRaycastHit.GetClass(hit)).ClassPointer.Handle;
		}
		
		delegate IntPtr raycastClosestShape_119_delegate(IntPtr worldRay, NxShapesType shapeType, IntPtr hit);
		
		
		
		
		
		
		private raycastClosestShape_119_delegate raycastClosestShape_119_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space sphere. </summary>
		/// <param name="worldSphere">Sphere description in world space. Range: See NxSphere</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the sphere against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapSphereShapes(NxSphere worldSphere, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask, bool accurateCollision)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapSphereShapes_INVOKE(ClassPointer, doSetFunctionPointers, (worldSphere!=null ? worldSphere.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef), accurateCollision);
		}
		
		private uint overlapSphereShapes_virtual(IntPtr worldSphere, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask, bool accurateCollision)
		{
			return overlapSphereShapes(NxSphere.GetClass(worldSphere), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask), accurateCollision);
		}
		
		delegate uint overlapSphereShapes_120_delegate(IntPtr worldSphere, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask, bool accurateCollision);
		
		
		
		
		
		
		private overlapSphereShapes_120_delegate overlapSphereShapes_120_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space sphere. </summary>
		/// <param name="worldSphere">Sphere description in world space. Range: See NxSphere</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the sphere against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapSphereShapes(NxSphere worldSphere, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapSphereShapes_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldSphere!=null ? worldSphere.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint overlapSphereShapes_virtual(IntPtr worldSphere, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask)
		{
			return overlapSphereShapes(NxSphere.GetClass(worldSphere), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint overlapSphereShapes_121_delegate(IntPtr worldSphere, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private overlapSphereShapes_121_delegate overlapSphereShapes_121_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space sphere. </summary>
		/// <param name="worldSphere">Sphere description in world space. Range: See NxSphere</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the sphere against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapSphereShapes(NxSphere worldSphere, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapSphereShapes_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldSphere!=null ? worldSphere.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups);
		}
		
		private uint overlapSphereShapes_virtual(IntPtr worldSphere, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups)
		{
			return overlapSphereShapes(NxSphere.GetClass(worldSphere), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups);
		}
		
		delegate uint overlapSphereShapes_122_delegate(IntPtr worldSphere, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups);
		
		
		
		
		
		
		private overlapSphereShapes_122_delegate overlapSphereShapes_122_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space sphere. </summary>
		/// <param name="worldSphere">Sphere description in world space. Range: See NxSphere</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the sphere against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapSphereShapes(NxSphere worldSphere, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapSphereShapes_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldSphere!=null ? worldSphere.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private uint overlapSphereShapes_virtual(IntPtr worldSphere, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback)
		{
			return overlapSphereShapes(NxSphere.GetClass(worldSphere), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback));
		}
		
		delegate uint overlapSphereShapes_123_delegate(IntPtr worldSphere, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback);
		
		
		
		
		
		
		private overlapSphereShapes_123_delegate overlapSphereShapes_123_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space AABB. </summary>
		/// <param name="worldBounds">Axis Aligned Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the AABB against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapAABBShapes(NxBounds3 worldBounds, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask, bool accurateCollision)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapAABBShapes_INVOKE(ClassPointer, doSetFunctionPointers, (worldBounds!=null ? worldBounds.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef), accurateCollision);
		}
		
		private uint overlapAABBShapes_virtual(IntPtr worldBounds, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask, bool accurateCollision)
		{
			return overlapAABBShapes(NxBounds3.GetClass(worldBounds), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask), accurateCollision);
		}
		
		delegate uint overlapAABBShapes_124_delegate(IntPtr worldBounds, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask, bool accurateCollision);
		
		
		
		
		
		
		private overlapAABBShapes_124_delegate overlapAABBShapes_124_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space AABB. </summary>
		/// <param name="worldBounds">Axis Aligned Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the AABB against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapAABBShapes(NxBounds3 worldBounds, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapAABBShapes_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldBounds!=null ? worldBounds.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint overlapAABBShapes_virtual(IntPtr worldBounds, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask)
		{
			return overlapAABBShapes(NxBounds3.GetClass(worldBounds), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint overlapAABBShapes_125_delegate(IntPtr worldBounds, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private overlapAABBShapes_125_delegate overlapAABBShapes_125_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space AABB. </summary>
		/// <param name="worldBounds">Axis Aligned Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the AABB against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapAABBShapes(NxBounds3 worldBounds, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapAABBShapes_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldBounds!=null ? worldBounds.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups);
		}
		
		private uint overlapAABBShapes_virtual(IntPtr worldBounds, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups)
		{
			return overlapAABBShapes(NxBounds3.GetClass(worldBounds), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups);
		}
		
		delegate uint overlapAABBShapes_126_delegate(IntPtr worldBounds, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups);
		
		
		
		
		
		
		private overlapAABBShapes_126_delegate overlapAABBShapes_126_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space AABB. </summary>
		/// <param name="worldBounds">Axis Aligned Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the AABB against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapAABBShapes(NxBounds3 worldBounds, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapAABBShapes_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldBounds!=null ? worldBounds.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private uint overlapAABBShapes_virtual(IntPtr worldBounds, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback)
		{
			return overlapAABBShapes(NxBounds3.GetClass(worldBounds), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback));
		}
		
		delegate uint overlapAABBShapes_127_delegate(IntPtr worldBounds, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback);
		
		
		
		
		
		
		private overlapAABBShapes_127_delegate overlapAABBShapes_127_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space OBB. </summary>
		/// <param name="worldBox">Oriented Bounding Box in world space. Range: See NxBox</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the OBB against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapOBBShapes(NxBox worldBox, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask, bool accurateCollision)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapOBBShapes_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef), accurateCollision);
		}
		
		private uint overlapOBBShapes_virtual(IntPtr worldBox, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask, bool accurateCollision)
		{
			return overlapOBBShapes(NxBox.GetClass(worldBox), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask), accurateCollision);
		}
		
		delegate uint overlapOBBShapes_128_delegate(IntPtr worldBox, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask, bool accurateCollision);
		
		
		
		
		
		
		private overlapOBBShapes_128_delegate overlapOBBShapes_128_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space OBB. </summary>
		/// <param name="worldBox">Oriented Bounding Box in world space. Range: See NxBox</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the OBB against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapOBBShapes(NxBox worldBox, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapOBBShapes_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint overlapOBBShapes_virtual(IntPtr worldBox, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask)
		{
			return overlapOBBShapes(NxBox.GetClass(worldBox), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint overlapOBBShapes_129_delegate(IntPtr worldBox, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private overlapOBBShapes_129_delegate overlapOBBShapes_129_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space OBB. </summary>
		/// <param name="worldBox">Oriented Bounding Box in world space. Range: See NxBox</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the OBB against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapOBBShapes(NxBox worldBox, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapOBBShapes_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups);
		}
		
		private uint overlapOBBShapes_virtual(IntPtr worldBox, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups)
		{
			return overlapOBBShapes(NxBox.GetClass(worldBox), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups);
		}
		
		delegate uint overlapOBBShapes_130_delegate(IntPtr worldBox, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups);
		
		
		
		
		
		
		private overlapOBBShapes_130_delegate overlapOBBShapes_130_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space OBB. </summary>
		/// <param name="worldBox">Oriented Bounding Box in world space. Range: See NxBox</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the OBB against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapOBBShapes(NxBox worldBox, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapOBBShapes_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private uint overlapOBBShapes_virtual(IntPtr worldBox, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback)
		{
			return overlapOBBShapes(NxBox.GetClass(worldBox), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback));
		}
		
		delegate uint overlapOBBShapes_131_delegate(IntPtr worldBox, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback);
		
		
		
		
		
		
		private overlapOBBShapes_131_delegate overlapOBBShapes_131_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space capsule. </summary>
		/// <param name="worldCapsule">capsule in world space. Range: See NxCapsule</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the capsule against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapCapsuleShapes(NxCapsule worldCapsule, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask, bool accurateCollision)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapCapsuleShapes_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef), accurateCollision);
		}
		
		private uint overlapCapsuleShapes_virtual(IntPtr worldCapsule, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask, bool accurateCollision)
		{
			return overlapCapsuleShapes(NxCapsule.GetClass(worldCapsule), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask), accurateCollision);
		}
		
		delegate uint overlapCapsuleShapes_132_delegate(IntPtr worldCapsule, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask, bool accurateCollision);
		
		
		
		
		
		
		private overlapCapsuleShapes_132_delegate overlapCapsuleShapes_132_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space capsule. </summary>
		/// <param name="worldCapsule">capsule in world space. Range: See NxCapsule</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the capsule against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapCapsuleShapes(NxCapsule worldCapsule, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapCapsuleShapes_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint overlapCapsuleShapes_virtual(IntPtr worldCapsule, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask)
		{
			return overlapCapsuleShapes(NxCapsule.GetClass(worldCapsule), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint overlapCapsuleShapes_133_delegate(IntPtr worldCapsule, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private overlapCapsuleShapes_133_delegate overlapCapsuleShapes_133_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space capsule. </summary>
		/// <param name="worldCapsule">capsule in world space. Range: See NxCapsule</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the capsule against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapCapsuleShapes(NxCapsule worldCapsule, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapCapsuleShapes_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups);
		}
		
		private uint overlapCapsuleShapes_virtual(IntPtr worldCapsule, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups)
		{
			return overlapCapsuleShapes(NxCapsule.GetClass(worldCapsule), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups);
		}
		
		delegate uint overlapCapsuleShapes_134_delegate(IntPtr worldCapsule, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups);
		
		
		
		
		
		
		private overlapCapsuleShapes_134_delegate overlapCapsuleShapes_134_delegatefield;
		
		/// <summary>Returns the set of shapes overlapped by the world-space capsule. </summary>
		/// <param name="worldCapsule">capsule in world space. Range: See NxCapsule</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		/// <param name="accurateCollision">True to test the capsule against the actual shapes, false to test against the AABBs only.</param>
		public virtual uint overlapCapsuleShapes(NxCapsule worldCapsule, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_overlapCapsuleShapes_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private uint overlapCapsuleShapes_virtual(IntPtr worldCapsule, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback)
		{
			return overlapCapsuleShapes(NxCapsule.GetClass(worldCapsule), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback));
		}
		
		delegate uint overlapCapsuleShapes_135_delegate(IntPtr worldCapsule, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback);
		
		
		
		
		
		
		private overlapCapsuleShapes_135_delegate overlapCapsuleShapes_135_delegatefield;
		
		/// <summary>Creates a sweep cache, for use with NxActor::linearSweep(). See the Guide, "Sweep API" section for more information. </summary>
		public virtual NxSweepCache createSweepCache()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxSweepCache.GetClass(NxScene_createSweepCache_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr createSweepCache_virtual()
		{
			return createSweepCache().ClassPointer.Handle;
		}
		
		delegate IntPtr createSweepCache_136_delegate();
		
		
		
		
		
		
		private createSweepCache_136_delegate createSweepCache_136_delegatefield;
		
		/// <summary>Deletes a sweep cache. See the Guide, "Sweep API" section, for more information on sweep caches. Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls). </summary>
		public virtual void releaseSweepCache(NxSweepCache cache)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseSweepCache_INVOKE(ClassPointer, doSetFunctionPointers, (cache!=null ? cache.ClassPointer : NullRef));
		}
		
		private void releaseSweepCache_virtual(IntPtr cache)
		{
			releaseSweepCache(NxSweepCache.GetClass(cache));
		}
		
		delegate void releaseSweepCache_137_delegate(IntPtr cache);
		
		
		
		
		
		
		private releaseSweepCache_137_delegate releaseSweepCache_137_delegatefield;
		
		/// <summary>Performs a linear sweep through space with an oriented box. </summary>
		/// <param name="worldBox">The oriented box (NxBox object) that is to be swept </param>
		/// <param name="motion">Length and direction of the sweep </param>
		/// <param name="flags">Flags controlling the mode of the sweep </param>
		/// <param name="userData">User data to impart to the returned data struct </param>
		/// <param name="nbShapes">Maximum number of shapes to report Range: [1,NX_MAX_U32] </param>
		/// <param name="shapes">Pointer to buffer for reported shapes </param>
		/// <param name="callback">Callback function invoked on the closest hit (if any) </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint linearOBBSweep(NxBox worldBox, ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, NxSweepQueryHit shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_linearOBBSweep_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), ref motion, flags, userData, nbShapes, (shapes!=null ? shapes.ClassPointer : NullRef), (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint linearOBBSweep_virtual(IntPtr worldBox, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask)
		{
			return linearOBBSweep(NxBox.GetClass(worldBox), ref motion, flags, userData, nbShapes, NxSweepQueryHit.GetClass(shapes), NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint linearOBBSweep_138_delegate(IntPtr worldBox, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private linearOBBSweep_138_delegate linearOBBSweep_138_delegatefield;
		
		/// <summary>Performs a linear sweep through space with an oriented box. </summary>
		/// <param name="worldBox">The oriented box (NxBox object) that is to be swept </param>
		/// <param name="motion">Length and direction of the sweep </param>
		/// <param name="flags">Flags controlling the mode of the sweep </param>
		/// <param name="userData">User data to impart to the returned data struct </param>
		/// <param name="nbShapes">Maximum number of shapes to report Range: [1,NX_MAX_U32] </param>
		/// <param name="shapes">Pointer to buffer for reported shapes </param>
		/// <param name="callback">Callback function invoked on the closest hit (if any) </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint linearOBBSweep(NxBox worldBox, ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, NxSweepQueryHit shapes, NxUserEntityReport callback, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_linearOBBSweep_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), ref motion, flags, userData, nbShapes, (shapes!=null ? shapes.ClassPointer : NullRef), (callback!=null ? callback.ClassPointer : NullRef), activeGroups);
		}
		
		private uint linearOBBSweep_virtual(IntPtr worldBox, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback, uint activeGroups)
		{
			return linearOBBSweep(NxBox.GetClass(worldBox), ref motion, flags, userData, nbShapes, NxSweepQueryHit.GetClass(shapes), NxUserEntityReport.GetClass(callback), activeGroups);
		}
		
		delegate uint linearOBBSweep_139_delegate(IntPtr worldBox, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback, uint activeGroups);
		
		
		
		
		
		
		private linearOBBSweep_139_delegate linearOBBSweep_139_delegatefield;
		
		/// <summary>Performs a linear sweep through space with an oriented box. </summary>
		/// <param name="worldBox">The oriented box (NxBox object) that is to be swept </param>
		/// <param name="motion">Length and direction of the sweep </param>
		/// <param name="flags">Flags controlling the mode of the sweep </param>
		/// <param name="userData">User data to impart to the returned data struct </param>
		/// <param name="nbShapes">Maximum number of shapes to report Range: [1,NX_MAX_U32] </param>
		/// <param name="shapes">Pointer to buffer for reported shapes </param>
		/// <param name="callback">Callback function invoked on the closest hit (if any) </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint linearOBBSweep(NxBox worldBox, ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, NxSweepQueryHit shapes, NxUserEntityReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_linearOBBSweep_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), ref motion, flags, userData, nbShapes, (shapes!=null ? shapes.ClassPointer : NullRef), (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private uint linearOBBSweep_virtual(IntPtr worldBox, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback)
		{
			return linearOBBSweep(NxBox.GetClass(worldBox), ref motion, flags, userData, nbShapes, NxSweepQueryHit.GetClass(shapes), NxUserEntityReport.GetClass(callback));
		}
		
		delegate uint linearOBBSweep_140_delegate(IntPtr worldBox, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback);
		
		
		
		
		
		
		private linearOBBSweep_140_delegate linearOBBSweep_140_delegatefield;
		
		/// <summary>Performs a linear sweep through space with an oriented capsule. </summary>
		/// <param name="worldCapsule">The oriented capsule (NxCapsule object) that is to be swept </param>
		/// <param name="motion">Length and direction of the sweep </param>
		/// <param name="flags">Flags controlling the mode of the sweep </param>
		/// <param name="userData">User data to impart to the returned data struct </param>
		/// <param name="nbShapes">Maximum number of shapes to report Range: [1,NX_MAX_U32] </param>
		/// <param name="shapes">Pointer to buffer for reported shapes </param>
		/// <param name="callback">Callback function invoked on the closest hit (if any) </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint linearCapsuleSweep(NxCapsule worldCapsule, ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, NxSweepQueryHit shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_linearCapsuleSweep_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), ref motion, flags, userData, nbShapes, (shapes!=null ? shapes.ClassPointer : NullRef), (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint linearCapsuleSweep_virtual(IntPtr worldCapsule, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask)
		{
			return linearCapsuleSweep(NxCapsule.GetClass(worldCapsule), ref motion, flags, userData, nbShapes, NxSweepQueryHit.GetClass(shapes), NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint linearCapsuleSweep_141_delegate(IntPtr worldCapsule, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private linearCapsuleSweep_141_delegate linearCapsuleSweep_141_delegatefield;
		
		/// <summary>Performs a linear sweep through space with an oriented capsule. </summary>
		/// <param name="worldCapsule">The oriented capsule (NxCapsule object) that is to be swept </param>
		/// <param name="motion">Length and direction of the sweep </param>
		/// <param name="flags">Flags controlling the mode of the sweep </param>
		/// <param name="userData">User data to impart to the returned data struct </param>
		/// <param name="nbShapes">Maximum number of shapes to report Range: [1,NX_MAX_U32] </param>
		/// <param name="shapes">Pointer to buffer for reported shapes </param>
		/// <param name="callback">Callback function invoked on the closest hit (if any) </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint linearCapsuleSweep(NxCapsule worldCapsule, ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, NxSweepQueryHit shapes, NxUserEntityReport callback, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_linearCapsuleSweep_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), ref motion, flags, userData, nbShapes, (shapes!=null ? shapes.ClassPointer : NullRef), (callback!=null ? callback.ClassPointer : NullRef), activeGroups);
		}
		
		private uint linearCapsuleSweep_virtual(IntPtr worldCapsule, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback, uint activeGroups)
		{
			return linearCapsuleSweep(NxCapsule.GetClass(worldCapsule), ref motion, flags, userData, nbShapes, NxSweepQueryHit.GetClass(shapes), NxUserEntityReport.GetClass(callback), activeGroups);
		}
		
		delegate uint linearCapsuleSweep_142_delegate(IntPtr worldCapsule, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback, uint activeGroups);
		
		
		
		
		
		
		private linearCapsuleSweep_142_delegate linearCapsuleSweep_142_delegatefield;
		
		/// <summary>Performs a linear sweep through space with an oriented capsule. </summary>
		/// <param name="worldCapsule">The oriented capsule (NxCapsule object) that is to be swept </param>
		/// <param name="motion">Length and direction of the sweep </param>
		/// <param name="flags">Flags controlling the mode of the sweep </param>
		/// <param name="userData">User data to impart to the returned data struct </param>
		/// <param name="nbShapes">Maximum number of shapes to report Range: [1,NX_MAX_U32] </param>
		/// <param name="shapes">Pointer to buffer for reported shapes </param>
		/// <param name="callback">Callback function invoked on the closest hit (if any) </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint linearCapsuleSweep(NxCapsule worldCapsule, ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, NxSweepQueryHit shapes, NxUserEntityReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_linearCapsuleSweep_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), ref motion, flags, userData, nbShapes, (shapes!=null ? shapes.ClassPointer : NullRef), (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private uint linearCapsuleSweep_virtual(IntPtr worldCapsule, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback)
		{
			return linearCapsuleSweep(NxCapsule.GetClass(worldCapsule), ref motion, flags, userData, nbShapes, NxSweepQueryHit.GetClass(shapes), NxUserEntityReport.GetClass(callback));
		}
		
		delegate uint linearCapsuleSweep_143_delegate(IntPtr worldCapsule, [In()] ref NxVec3 motion, uint flags, System.IntPtr userData, uint nbShapes, IntPtr shapes, IntPtr callback);
		
		
		
		
		
		
		private linearCapsuleSweep_143_delegate linearCapsuleSweep_143_delegatefield;
		
		/// <summary>Returns the set of shapes which are in the negative half space of a number of planes. </summary>
		/// <param name="nbPlanes">Number of planes to test. (worldPlanes should contain this many planes) </param>
		/// <param name="worldPlanes">Set of planes to test. Range: See NxPlane</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint cullShapes(uint nbPlanes, NxPlane worldPlanes, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_cullShapes_INVOKE(ClassPointer, doSetFunctionPointers, nbPlanes, (worldPlanes!=null ? worldPlanes.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private uint cullShapes_virtual(uint nbPlanes, IntPtr worldPlanes, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask)
		{
			return cullShapes(nbPlanes, NxPlane.GetClass(worldPlanes), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate uint cullShapes_144_delegate(uint nbPlanes, IntPtr worldPlanes, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private cullShapes_144_delegate cullShapes_144_delegatefield;
		
		/// <summary>Returns the set of shapes which are in the negative half space of a number of planes. </summary>
		/// <param name="nbPlanes">Number of planes to test. (worldPlanes should contain this many planes) </param>
		/// <param name="worldPlanes">Set of planes to test. Range: See NxPlane</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint cullShapes(uint nbPlanes, NxPlane worldPlanes, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_cullShapes_1_INVOKE(ClassPointer, doSetFunctionPointers, nbPlanes, (worldPlanes!=null ? worldPlanes.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef), activeGroups);
		}
		
		private uint cullShapes_virtual(uint nbPlanes, IntPtr worldPlanes, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups)
		{
			return cullShapes(nbPlanes, NxPlane.GetClass(worldPlanes), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback), activeGroups);
		}
		
		delegate uint cullShapes_145_delegate(uint nbPlanes, IntPtr worldPlanes, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback, uint activeGroups);
		
		
		
		
		
		
		private cullShapes_145_delegate cullShapes_145_delegatefield;
		
		/// <summary>Returns the set of shapes which are in the negative half space of a number of planes. </summary>
		/// <param name="nbPlanes">Number of planes to test. (worldPlanes should contain this many planes) </param>
		/// <param name="worldPlanes">Set of planes to test. Range: See NxPlane</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="nbShapes">Number of shapes that the buffer shapes can hold. </param>
		/// <param name="shapes">Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </param>
		/// <param name="callback">Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual uint cullShapes(uint nbPlanes, NxPlane worldPlanes, NxShapesType shapeType, uint nbShapes, DoxyBindArray<NxShape> shapes, NxUserEntityReport callback)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_cullShapes_2_INVOKE(ClassPointer, doSetFunctionPointers, nbPlanes, (worldPlanes!=null ? worldPlanes.ClassPointer : NullRef), shapeType, nbShapes, shapes, (callback!=null ? callback.ClassPointer : NullRef));
		}
		
		private uint cullShapes_virtual(uint nbPlanes, IntPtr worldPlanes, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback)
		{
			return cullShapes(nbPlanes, NxPlane.GetClass(worldPlanes), shapeType, nbShapes, shapes, NxUserEntityReport.GetClass(callback));
		}
		
		delegate uint cullShapes_146_delegate(uint nbPlanes, IntPtr worldPlanes, NxShapesType shapeType, uint nbShapes, IntPtr[] shapes, IntPtr callback);
		
		
		
		
		
		
		private cullShapes_146_delegate cullShapes_146_delegatefield;
		
		/// <summary>Checks whether a world-space sphere overlaps a shape or not. </summary>
		/// <param name="worldSphere">Sphere description in world space. Range: See NxSphere</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapSphere(NxSphere worldSphere, NxShapesType shapeType, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapSphere_INVOKE(ClassPointer, doSetFunctionPointers, (worldSphere!=null ? worldSphere.ClassPointer : NullRef), shapeType, activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private bool checkOverlapSphere_virtual(IntPtr worldSphere, NxShapesType shapeType, uint activeGroups, IntPtr groupsMask)
		{
			return checkOverlapSphere(NxSphere.GetClass(worldSphere), shapeType, activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate bool checkOverlapSphere_147_delegate(IntPtr worldSphere, NxShapesType shapeType, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private checkOverlapSphere_147_delegate checkOverlapSphere_147_delegatefield;
		
		/// <summary>Checks whether a world-space sphere overlaps a shape or not. </summary>
		/// <param name="worldSphere">Sphere description in world space. Range: See NxSphere</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapSphere(NxSphere worldSphere, NxShapesType shapeType, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapSphere_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldSphere!=null ? worldSphere.ClassPointer : NullRef), shapeType, activeGroups);
		}
		
		private bool checkOverlapSphere_virtual(IntPtr worldSphere, NxShapesType shapeType, uint activeGroups)
		{
			return checkOverlapSphere(NxSphere.GetClass(worldSphere), shapeType, activeGroups);
		}
		
		delegate bool checkOverlapSphere_148_delegate(IntPtr worldSphere, NxShapesType shapeType, uint activeGroups);
		
		
		
		
		
		
		private checkOverlapSphere_148_delegate checkOverlapSphere_148_delegatefield;
		
		/// <summary>Checks whether a world-space sphere overlaps a shape or not. </summary>
		/// <param name="worldSphere">Sphere description in world space. Range: See NxSphere</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapSphere(NxSphere worldSphere, NxShapesType shapeType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapSphere_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldSphere!=null ? worldSphere.ClassPointer : NullRef), shapeType);
		}
		
		private bool checkOverlapSphere_virtual(IntPtr worldSphere, NxShapesType shapeType)
		{
			return checkOverlapSphere(NxSphere.GetClass(worldSphere), shapeType);
		}
		
		delegate bool checkOverlapSphere_149_delegate(IntPtr worldSphere, NxShapesType shapeType);
		
		
		
		
		
		
		private checkOverlapSphere_149_delegate checkOverlapSphere_149_delegatefield;
		
		/// <summary>Checks whether a world-space sphere overlaps a shape or not. </summary>
		/// <param name="worldSphere">Sphere description in world space. Range: See NxSphere</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapSphere(NxSphere worldSphere)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapSphere_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldSphere!=null ? worldSphere.ClassPointer : NullRef));
		}
		
		private bool checkOverlapSphere_virtual(IntPtr worldSphere)
		{
			return checkOverlapSphere(NxSphere.GetClass(worldSphere));
		}
		
		delegate bool checkOverlapSphere_150_delegate(IntPtr worldSphere);
		
		
		
		
		
		
		private checkOverlapSphere_150_delegate checkOverlapSphere_150_delegatefield;
		
		/// <summary>Checks whether a world-space AABB overlaps a shape or not. </summary>
		/// <param name="worldBounds">Axis Aligned Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapAABB(NxBounds3 worldBounds, NxShapesType shapeType, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapAABB_INVOKE(ClassPointer, doSetFunctionPointers, (worldBounds!=null ? worldBounds.ClassPointer : NullRef), shapeType, activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private bool checkOverlapAABB_virtual(IntPtr worldBounds, NxShapesType shapeType, uint activeGroups, IntPtr groupsMask)
		{
			return checkOverlapAABB(NxBounds3.GetClass(worldBounds), shapeType, activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate bool checkOverlapAABB_151_delegate(IntPtr worldBounds, NxShapesType shapeType, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private checkOverlapAABB_151_delegate checkOverlapAABB_151_delegatefield;
		
		/// <summary>Checks whether a world-space AABB overlaps a shape or not. </summary>
		/// <param name="worldBounds">Axis Aligned Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapAABB(NxBounds3 worldBounds, NxShapesType shapeType, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapAABB_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldBounds!=null ? worldBounds.ClassPointer : NullRef), shapeType, activeGroups);
		}
		
		private bool checkOverlapAABB_virtual(IntPtr worldBounds, NxShapesType shapeType, uint activeGroups)
		{
			return checkOverlapAABB(NxBounds3.GetClass(worldBounds), shapeType, activeGroups);
		}
		
		delegate bool checkOverlapAABB_152_delegate(IntPtr worldBounds, NxShapesType shapeType, uint activeGroups);
		
		
		
		
		
		
		private checkOverlapAABB_152_delegate checkOverlapAABB_152_delegatefield;
		
		/// <summary>Checks whether a world-space AABB overlaps a shape or not. </summary>
		/// <param name="worldBounds">Axis Aligned Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapAABB(NxBounds3 worldBounds, NxShapesType shapeType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapAABB_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldBounds!=null ? worldBounds.ClassPointer : NullRef), shapeType);
		}
		
		private bool checkOverlapAABB_virtual(IntPtr worldBounds, NxShapesType shapeType)
		{
			return checkOverlapAABB(NxBounds3.GetClass(worldBounds), shapeType);
		}
		
		delegate bool checkOverlapAABB_153_delegate(IntPtr worldBounds, NxShapesType shapeType);
		
		
		
		
		
		
		private checkOverlapAABB_153_delegate checkOverlapAABB_153_delegatefield;
		
		/// <summary>Checks whether a world-space AABB overlaps a shape or not. </summary>
		/// <param name="worldBounds">Axis Aligned Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapAABB(NxBounds3 worldBounds)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapAABB_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldBounds!=null ? worldBounds.ClassPointer : NullRef));
		}
		
		private bool checkOverlapAABB_virtual(IntPtr worldBounds)
		{
			return checkOverlapAABB(NxBounds3.GetClass(worldBounds));
		}
		
		delegate bool checkOverlapAABB_154_delegate(IntPtr worldBounds);
		
		
		
		
		
		
		private checkOverlapAABB_154_delegate checkOverlapAABB_154_delegatefield;
		
		/// <summary>Checks whether a world-space OBB overlaps a shape or not. </summary>
		/// <param name="worldBox">Oriented Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapOBB(NxBox worldBox, NxShapesType shapeType, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapOBB_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), shapeType, activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private bool checkOverlapOBB_virtual(IntPtr worldBox, NxShapesType shapeType, uint activeGroups, IntPtr groupsMask)
		{
			return checkOverlapOBB(NxBox.GetClass(worldBox), shapeType, activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate bool checkOverlapOBB_155_delegate(IntPtr worldBox, NxShapesType shapeType, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private checkOverlapOBB_155_delegate checkOverlapOBB_155_delegatefield;
		
		/// <summary>Checks whether a world-space OBB overlaps a shape or not. </summary>
		/// <param name="worldBox">Oriented Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapOBB(NxBox worldBox, NxShapesType shapeType, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapOBB_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), shapeType, activeGroups);
		}
		
		private bool checkOverlapOBB_virtual(IntPtr worldBox, NxShapesType shapeType, uint activeGroups)
		{
			return checkOverlapOBB(NxBox.GetClass(worldBox), shapeType, activeGroups);
		}
		
		delegate bool checkOverlapOBB_156_delegate(IntPtr worldBox, NxShapesType shapeType, uint activeGroups);
		
		
		
		
		
		
		private checkOverlapOBB_156_delegate checkOverlapOBB_156_delegatefield;
		
		/// <summary>Checks whether a world-space OBB overlaps a shape or not. </summary>
		/// <param name="worldBox">Oriented Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapOBB(NxBox worldBox, NxShapesType shapeType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapOBB_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef), shapeType);
		}
		
		private bool checkOverlapOBB_virtual(IntPtr worldBox, NxShapesType shapeType)
		{
			return checkOverlapOBB(NxBox.GetClass(worldBox), shapeType);
		}
		
		delegate bool checkOverlapOBB_157_delegate(IntPtr worldBox, NxShapesType shapeType);
		
		
		
		
		
		
		private checkOverlapOBB_157_delegate checkOverlapOBB_157_delegatefield;
		
		/// <summary>Checks whether a world-space OBB overlaps a shape or not. </summary>
		/// <param name="worldBox">Oriented Bounding Box in world space. Range: See NxBounds3</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapOBB(NxBox worldBox)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapOBB_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldBox!=null ? worldBox.ClassPointer : NullRef));
		}
		
		private bool checkOverlapOBB_virtual(IntPtr worldBox)
		{
			return checkOverlapOBB(NxBox.GetClass(worldBox));
		}
		
		delegate bool checkOverlapOBB_158_delegate(IntPtr worldBox);
		
		
		
		
		
		
		private checkOverlapOBB_158_delegate checkOverlapOBB_158_delegatefield;
		
		/// <summary>Checks whether a world-space capsule overlaps something or not. </summary>
		/// <param name="worldCapsule">Capsule description in world space. Range: See NxCapsule</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapCapsule(NxCapsule worldCapsule, NxShapesType shapeType, uint activeGroups, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapCapsule_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), shapeType, activeGroups, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private bool checkOverlapCapsule_virtual(IntPtr worldCapsule, NxShapesType shapeType, uint activeGroups, IntPtr groupsMask)
		{
			return checkOverlapCapsule(NxCapsule.GetClass(worldCapsule), shapeType, activeGroups, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate bool checkOverlapCapsule_159_delegate(IntPtr worldCapsule, NxShapesType shapeType, uint activeGroups, IntPtr groupsMask);
		
		
		
		
		
		
		private checkOverlapCapsule_159_delegate checkOverlapCapsule_159_delegatefield;
		
		/// <summary>Checks whether a world-space capsule overlaps something or not. </summary>
		/// <param name="worldCapsule">Capsule description in world space. Range: See NxCapsule</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapCapsule(NxCapsule worldCapsule, NxShapesType shapeType, uint activeGroups)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapCapsule_1_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), shapeType, activeGroups);
		}
		
		private bool checkOverlapCapsule_virtual(IntPtr worldCapsule, NxShapesType shapeType, uint activeGroups)
		{
			return checkOverlapCapsule(NxCapsule.GetClass(worldCapsule), shapeType, activeGroups);
		}
		
		delegate bool checkOverlapCapsule_160_delegate(IntPtr worldCapsule, NxShapesType shapeType, uint activeGroups);
		
		
		
		
		
		
		private checkOverlapCapsule_160_delegate checkOverlapCapsule_160_delegatefield;
		
		/// <summary>Checks whether a world-space capsule overlaps something or not. </summary>
		/// <param name="worldCapsule">Capsule description in world space. Range: See NxCapsule</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapCapsule(NxCapsule worldCapsule, NxShapesType shapeType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapCapsule_2_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef), shapeType);
		}
		
		private bool checkOverlapCapsule_virtual(IntPtr worldCapsule, NxShapesType shapeType)
		{
			return checkOverlapCapsule(NxCapsule.GetClass(worldCapsule), shapeType);
		}
		
		delegate bool checkOverlapCapsule_161_delegate(IntPtr worldCapsule, NxShapesType shapeType);
		
		
		
		
		
		
		private checkOverlapCapsule_161_delegate checkOverlapCapsule_161_delegatefield;
		
		/// <summary>Checks whether a world-space capsule overlaps something or not. </summary>
		/// <param name="worldCapsule">Capsule description in world space. Range: See NxCapsule</param>
		/// <param name="shapeType">Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </param>
		/// <param name="activeGroups">Mask used to filter shape objects. See NxShape::setGroup</param>
		/// <param name="groupsMask">Alternative mask used to filter shapes. See NxShape::setGroupsMask</param>
		public virtual bool checkOverlapCapsule(NxCapsule worldCapsule)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkOverlapCapsule_3_INVOKE(ClassPointer, doSetFunctionPointers, (worldCapsule!=null ? worldCapsule.ClassPointer : NullRef));
		}
		
		private bool checkOverlapCapsule_virtual(IntPtr worldCapsule)
		{
			return checkOverlapCapsule(NxCapsule.GetClass(worldCapsule));
		}
		
		delegate bool checkOverlapCapsule_162_delegate(IntPtr worldCapsule);
		
		
		
		
		
		
		private checkOverlapCapsule_162_delegate checkOverlapCapsule_162_delegatefield;
		
		/// <summary>Creates a fluid in this scene. </summary>
		/// <param name="fluidDesc">Description of the fluid object to create. See NxFluidDesc. </param>
		public virtual NxFluid createFluid(NxFluidDescBase fluidDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxFluid.GetClass(NxScene_createFluid_INVOKE(ClassPointer, doSetFunctionPointers, (fluidDesc!=null ? fluidDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createFluid_virtual(IntPtr fluidDesc)
		{
			return createFluid(NxFluidDescBase.GetClass(fluidDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createFluid_163_delegate(IntPtr fluidDesc);
		
		
		
		
		
		
		private createFluid_163_delegate createFluid_163_delegatefield;
		
		/// <summary>Deletes the specified fluid. The fluid must be in this scene. </summary>
		/// <param name="fluid">Fluid to release.</param>
		public virtual void releaseFluid(NxFluid fluid)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseFluid_INVOKE(ClassPointer, doSetFunctionPointers, (fluid!=null ? fluid.ClassPointer : NullRef));
		}
		
		private void releaseFluid_virtual(IntPtr fluid)
		{
			releaseFluid(NxFluid.GetClass(fluid));
		}
		
		delegate void releaseFluid_164_delegate(IntPtr fluid);
		
		
		
		
		
		
		private releaseFluid_164_delegate releaseFluid_164_delegatefield;
		
		/// <summary>Get the number of fluids belonging to the scene. </summary>
		public virtual uint getNbFluids()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbFluids_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbFluids_virtual()
		{
			return getNbFluids();
		}
		
		delegate uint getNbFluids_165_delegate();
		
		
		
		
		
		
		private getNbFluids_165_delegate getNbFluids_165_delegatefield;
		
		/// <summary>Get an array of fluids belonging to the scene. </summary>
		public virtual DoxyBindArray<NxFluid> getFluids()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getFluids_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private IntPtr[] getFluids_virtual()
		{
			return getFluids();
		}
		
		delegate IntPtr[] getFluids_166_delegate();
		
		
		
		
		
		
		private getFluids_166_delegate getFluids_166_delegatefield;
		
		/// <summary>Pre-cooks all triangles from static NxTriangleMeshShapes of the scene which are intersecting with the given bounds. </summary>
		/// <param name="bounds">The volume whose contents should be pre-cooked </param>
		/// <param name="packetSizeMultiplier"></param>
		/// <param name="restParticlesPerMeter"></param>
		/// <param name="kernelRadiusMultiplier"></param>
		/// <param name="motionLimitMultiplier"></param>
		/// <param name="collisionDistanceMultiplier"></param>
		/// <param name="compartment">The specific compartment to perform the pre-cooking for. </param>
		/// <param name="forceStrictCookingFormat">Forces specified cooking parameters. Otherwise they might internaly be reinterpreted depending on created fluids. Not implemented yet.</param>
		public virtual bool cookFluidMeshHotspot(NxBounds3 bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier, NxCompartment compartment, bool forceStrictCookingFormat)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_cookFluidMeshHotspot_INVOKE(ClassPointer, doSetFunctionPointers, (bounds!=null ? bounds.ClassPointer : NullRef), packetSizeMultiplier, restParticlesPerMeter, kernelRadiusMultiplier, motionLimitMultiplier, collisionDistanceMultiplier, (compartment!=null ? compartment.ClassPointer : NullRef), forceStrictCookingFormat);
		}
		
		private bool cookFluidMeshHotspot_virtual(IntPtr bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier, IntPtr compartment, bool forceStrictCookingFormat)
		{
			return cookFluidMeshHotspot(NxBounds3.GetClass(bounds), packetSizeMultiplier, restParticlesPerMeter, kernelRadiusMultiplier, motionLimitMultiplier, collisionDistanceMultiplier, NxCompartment.GetClass(compartment), forceStrictCookingFormat);
		}
		
		delegate bool cookFluidMeshHotspot_167_delegate(IntPtr bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier, IntPtr compartment, bool forceStrictCookingFormat);
		
		
		
		
		
		
		private cookFluidMeshHotspot_167_delegate cookFluidMeshHotspot_167_delegatefield;
		
		/// <summary>Pre-cooks all triangles from static NxTriangleMeshShapes of the scene which are intersecting with the given bounds. </summary>
		/// <param name="bounds">The volume whose contents should be pre-cooked </param>
		/// <param name="packetSizeMultiplier"></param>
		/// <param name="restParticlesPerMeter"></param>
		/// <param name="kernelRadiusMultiplier"></param>
		/// <param name="motionLimitMultiplier"></param>
		/// <param name="collisionDistanceMultiplier"></param>
		/// <param name="compartment">The specific compartment to perform the pre-cooking for. </param>
		/// <param name="forceStrictCookingFormat">Forces specified cooking parameters. Otherwise they might internaly be reinterpreted depending on created fluids. Not implemented yet.</param>
		public virtual bool cookFluidMeshHotspot(NxBounds3 bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier, NxCompartment compartment)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_cookFluidMeshHotspot_1_INVOKE(ClassPointer, doSetFunctionPointers, (bounds!=null ? bounds.ClassPointer : NullRef), packetSizeMultiplier, restParticlesPerMeter, kernelRadiusMultiplier, motionLimitMultiplier, collisionDistanceMultiplier, (compartment!=null ? compartment.ClassPointer : NullRef));
		}
		
		private bool cookFluidMeshHotspot_virtual(IntPtr bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier, IntPtr compartment)
		{
			return cookFluidMeshHotspot(NxBounds3.GetClass(bounds), packetSizeMultiplier, restParticlesPerMeter, kernelRadiusMultiplier, motionLimitMultiplier, collisionDistanceMultiplier, NxCompartment.GetClass(compartment));
		}
		
		delegate bool cookFluidMeshHotspot_168_delegate(IntPtr bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier, IntPtr compartment);
		
		
		
		
		
		
		private cookFluidMeshHotspot_168_delegate cookFluidMeshHotspot_168_delegatefield;
		
		/// <summary>Pre-cooks all triangles from static NxTriangleMeshShapes of the scene which are intersecting with the given bounds. </summary>
		/// <param name="bounds">The volume whose contents should be pre-cooked </param>
		/// <param name="packetSizeMultiplier"></param>
		/// <param name="restParticlesPerMeter"></param>
		/// <param name="kernelRadiusMultiplier"></param>
		/// <param name="motionLimitMultiplier"></param>
		/// <param name="collisionDistanceMultiplier"></param>
		/// <param name="compartment">The specific compartment to perform the pre-cooking for. </param>
		/// <param name="forceStrictCookingFormat">Forces specified cooking parameters. Otherwise they might internaly be reinterpreted depending on created fluids. Not implemented yet.</param>
		public virtual bool cookFluidMeshHotspot(NxBounds3 bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_cookFluidMeshHotspot_2_INVOKE(ClassPointer, doSetFunctionPointers, (bounds!=null ? bounds.ClassPointer : NullRef), packetSizeMultiplier, restParticlesPerMeter, kernelRadiusMultiplier, motionLimitMultiplier, collisionDistanceMultiplier);
		}
		
		private bool cookFluidMeshHotspot_virtual(IntPtr bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier)
		{
			return cookFluidMeshHotspot(NxBounds3.GetClass(bounds), packetSizeMultiplier, restParticlesPerMeter, kernelRadiusMultiplier, motionLimitMultiplier, collisionDistanceMultiplier);
		}
		
		delegate bool cookFluidMeshHotspot_169_delegate(IntPtr bounds, uint packetSizeMultiplier, float restParticlesPerMeter, float kernelRadiusMultiplier, float motionLimitMultiplier, float collisionDistanceMultiplier);
		
		
		
		
		
		
		private cookFluidMeshHotspot_169_delegate cookFluidMeshHotspot_169_delegatefield;
		
		/// <summary></summary>
		/// <param name="clothDesc">Description of the cloth object to create. See NxClothDesc. </param>
		public virtual NxCloth createCloth(NxClothDesc clothDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxCloth.GetClass(NxScene_createCloth_INVOKE(ClassPointer, doSetFunctionPointers, (clothDesc!=null ? clothDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createCloth_virtual(IntPtr clothDesc)
		{
			return createCloth(NxClothDesc.GetClass(clothDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createCloth_170_delegate(IntPtr clothDesc);
		
		
		
		
		
		
		private createCloth_170_delegate createCloth_170_delegatefield;
		
		/// <summary></summary>
		/// <param name="cloth">Cloth to release.</param>
		public virtual void releaseCloth(NxCloth cloth)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseCloth_INVOKE(ClassPointer, doSetFunctionPointers, (cloth!=null ? cloth.ClassPointer : NullRef));
		}
		
		private void releaseCloth_virtual(IntPtr cloth)
		{
			releaseCloth(NxCloth.GetClass(cloth));
		}
		
		delegate void releaseCloth_171_delegate(IntPtr cloth);
		
		
		
		
		
		
		private releaseCloth_171_delegate releaseCloth_171_delegatefield;
		
		/// <summary></summary>
		public virtual uint getNbCloths()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbCloths_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbCloths_virtual()
		{
			return getNbCloths();
		}
		
		delegate uint getNbCloths_172_delegate();
		
		
		
		
		
		
		private getNbCloths_172_delegate getNbCloths_172_delegatefield;
		
		/// <summary>Returns an array of cloth objects. </summary>
		public virtual DoxyBindArray<NxCloth> getCloths()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getCloths_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private IntPtr[] getCloths_virtual()
		{
			return getCloths();
		}
		
		delegate IntPtr[] getCloths_173_delegate();
		
		
		
		
		
		
		private getCloths_173_delegate getCloths_173_delegatefield;
		
		/// <summary></summary>
		/// <param name="softBodyDesc">Description of the soft body object to create. See NxSoftBodyDesc. </param>
		public virtual NxSoftBody createSoftBody(NxSoftBodyDesc softBodyDesc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxSoftBody.GetClass(NxScene_createSoftBody_INVOKE(ClassPointer, doSetFunctionPointers, (softBodyDesc!=null ? softBodyDesc.ClassPointer : NullRef)));
		}
		
		private IntPtr createSoftBody_virtual(IntPtr softBodyDesc)
		{
			return createSoftBody(NxSoftBodyDesc.GetClass(softBodyDesc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createSoftBody_174_delegate(IntPtr softBodyDesc);
		
		
		
		
		
		
		private createSoftBody_174_delegate createSoftBody_174_delegatefield;
		
		/// <summary></summary>
		/// <param name="softBody">Soft body to release.</param>
		public virtual void releaseSoftBody(NxSoftBody softBody)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_releaseSoftBody_INVOKE(ClassPointer, doSetFunctionPointers, (softBody!=null ? softBody.ClassPointer : NullRef));
		}
		
		private void releaseSoftBody_virtual(IntPtr softBody)
		{
			releaseSoftBody(NxSoftBody.GetClass(softBody));
		}
		
		delegate void releaseSoftBody_175_delegate(IntPtr softBody);
		
		
		
		
		
		
		private releaseSoftBody_175_delegate releaseSoftBody_175_delegatefield;
		
		/// <summary></summary>
		public virtual uint getNbSoftBodies()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getNbSoftBodies_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getNbSoftBodies_virtual()
		{
			return getNbSoftBodies();
		}
		
		delegate uint getNbSoftBodies_176_delegate();
		
		
		
		
		
		
		private getNbSoftBodies_176_delegate getNbSoftBodies_176_delegatefield;
		
		/// <summary>Returns an array of soft body objects. </summary>
		public virtual DoxyBindArray<NxSoftBody> getSoftBodies()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getSoftBodies_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private IntPtr[] getSoftBodies_virtual()
		{
			return getSoftBodies();
		}
		
		delegate IntPtr[] getSoftBodies_177_delegate();
		
		
		
		
		
		
		private getSoftBodies_177_delegate getSoftBodies_177_delegatefield;
		
		/// <summary>user can assign this to whatever, usually to create a 1:1 relationship with a user object. </summary>
		public System.IntPtr userData
		{
			get
			{
				System.IntPtr value = get_NxScene_userData_INVOKE(ClassPointer);
				return value;
			}
			set
			{
				set_NxScene_userData_INVOKE(ClassPointer, value);
			}
		}
		
		/// <summary>reserved for linkage with other Ageia components. Applications and SDK should not modify </summary>
		public System.IntPtr extLink
		{
			get
			{
				System.IntPtr value = get_NxScene_extLink_INVOKE(ClassPointer);
				return value;
			}
			set
			{
				set_NxScene_extLink_INVOKE(ClassPointer, value);
			}
		}
		
		/// <summary></summary>
		protected NxScene() : 
				base(IntPtr.Zero)
		{
			if ((GetType() != typeof(NxScene)))
			{
				doSetFunctionPointers = true;
				SetPointer(new_NxScene_INVOKE(doSetFunctionPointers));
				System.IntPtr[] pointers = CreateFunctionPointers().ToArray();
				set_pointers_INVOKE(ClassPointer, pointers, pointers.Length);
			}
			else
			{
				SetPointer(new_NxScene_INVOKE(doSetFunctionPointers));
			}
			GC.ReRegisterForFinalize(this);
		}
		
		/// <summary>Saves the Scene descriptor. </summary>
		/// <param name="desc">The descriptor used to retrieve the state of the object. </param>
		public virtual bool saveToDesc(NxSceneDesc desc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_saveToDesc_INVOKE(ClassPointer, doSetFunctionPointers, (desc!=null ? desc.ClassPointer : NullRef));
		}
		
		private bool saveToDesc_virtual(IntPtr desc)
		{
			return saveToDesc(NxSceneDesc.GetClass(desc));
		}
		
		delegate bool saveToDesc_178_delegate(IntPtr desc);
		
		
		
		
		
		
		private saveToDesc_178_delegate saveToDesc_178_delegatefield;
		
		/// <summary>Get the scene flags. </summary>
		public virtual uint getFlags()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getFlags_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getFlags_virtual()
		{
			return getFlags();
		}
		
		delegate uint getFlags_179_delegate();
		
		
		
		
		
		
		private getFlags_179_delegate getFlags_179_delegatefield;
		
		/// <summary>Get the simulation type. </summary>
		public virtual NxSimulationType getSimType()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getSimType_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private NxSimulationType getSimType_virtual()
		{
			return getSimType();
		}
		
		delegate NxSimulationType getSimType_180_delegate();
		
		
		
		
		
		
		private getSimType_180_delegate getSimType_180_delegatefield;
		
		/// <summary>Gets a private interface to an internal debug object. </summary>
		public virtual System.IntPtr getInternal()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getInternal_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private System.IntPtr getInternal_virtual()
		{
			return getInternal();
		}
		
		delegate System.IntPtr getInternal_181_delegate();
		
		
		
		
		
		
		private getInternal_181_delegate getInternal_181_delegatefield;
		
		/// <summary>Sets a constant gravity for the entire scene. </summary>
		/// <param name="vec">A new gravity vector(e.g. NxVec3(0.0f,-9.8f,0.0f) ) Range: force vector</param>
		public virtual void setGravity(ref NxVec3 vec)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setGravity_INVOKE(ClassPointer, doSetFunctionPointers, ref vec);
		}
		
		private void setGravity_virtual([In()] ref NxVec3 vec)
		{
			setGravity(ref vec);
		}
		
		delegate void setGravity_182_delegate([In()] ref NxVec3 vec);
		
		
		
		
		
		
		private setGravity_182_delegate setGravity_182_delegatefield;
		
		/// <summary>Retrieves the current gravity setting. </summary>
		/// <param name="vec">Used to retrieve the current gravity for the scene.</param>
		public virtual void getGravity(ref NxVec3 vec)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_getGravity_INVOKE(ClassPointer, doSetFunctionPointers, ref vec);
		}
		
		private void getGravity_virtual([In()] [Out()] ref NxVec3 vec)
		{
			getGravity(ref vec);
		}
		
		delegate void getGravity_183_delegate([In()] [Out()] ref NxVec3 vec);
		
		
		
		
		
		
		private getGravity_183_delegate getGravity_183_delegatefield;
		
		/// <summary>Flush the scene's command queue for processing. </summary>
		public virtual void flushStream()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_flushStream_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void flushStream_virtual()
		{
			flushStream();
		}
		
		delegate void flushStream_184_delegate();
		
		
		
		
		
		
		private flushStream_184_delegate flushStream_184_delegatefield;
		
		/// <summary>Sets simulation timing parameters used in simulate(elapsedTime). </summary>
		/// <param name="maxTimestep">Maximum size of a substep. Range: (0,inf) </param>
		/// <param name="maxIter">Maximum number of iterations to divide a timestep into. </param>
		/// <param name="method">Method to use for timestep (either variable time step or fixed). See NxTimeStepMethod.</param>
		public virtual void setTiming(float maxTimestep, uint maxIter, NxTimeStepMethod method)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setTiming_INVOKE(ClassPointer, doSetFunctionPointers, maxTimestep, maxIter, method);
		}
		
		private void setTiming_virtual(float maxTimestep, uint maxIter, NxTimeStepMethod method)
		{
			setTiming(maxTimestep, maxIter, method);
		}
		
		delegate void setTiming_185_delegate(float maxTimestep, uint maxIter, NxTimeStepMethod method);
		
		
		
		
		
		
		private setTiming_185_delegate setTiming_185_delegatefield;
		
		/// <summary>Sets simulation timing parameters used in simulate(elapsedTime). </summary>
		/// <param name="maxTimestep">Maximum size of a substep. Range: (0,inf) </param>
		/// <param name="maxIter">Maximum number of iterations to divide a timestep into. </param>
		/// <param name="method">Method to use for timestep (either variable time step or fixed). See NxTimeStepMethod.</param>
		public virtual void setTiming(float maxTimestep, uint maxIter)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setTiming_1_INVOKE(ClassPointer, doSetFunctionPointers, maxTimestep, maxIter);
		}
		
		private void setTiming_virtual(float maxTimestep, uint maxIter)
		{
			setTiming(maxTimestep, maxIter);
		}
		
		delegate void setTiming_186_delegate(float maxTimestep, uint maxIter);
		
		
		
		
		
		
		private setTiming_186_delegate setTiming_186_delegatefield;
		
		/// <summary>Sets simulation timing parameters used in simulate(elapsedTime). </summary>
		/// <param name="maxTimestep">Maximum size of a substep. Range: (0,inf) </param>
		/// <param name="maxIter">Maximum number of iterations to divide a timestep into. </param>
		/// <param name="method">Method to use for timestep (either variable time step or fixed). See NxTimeStepMethod.</param>
		public virtual void setTiming(float maxTimestep)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setTiming_2_INVOKE(ClassPointer, doSetFunctionPointers, maxTimestep);
		}
		
		private void setTiming_virtual(float maxTimestep)
		{
			setTiming(maxTimestep);
		}
		
		delegate void setTiming_187_delegate(float maxTimestep);
		
		
		
		
		
		
		private setTiming_187_delegate setTiming_187_delegatefield;
		
		/// <summary>Retrieves simulation timing parameters. </summary>
		/// <param name="maxTimestep">Maximum size to divide a substep into. Range: (0,inf) </param>
		/// <param name="maxIter">Maximum number of iterations to divide a timestep into. </param>
		/// <param name="method">Method to use for timestep (either variable time step or fixed). See NxTimeStepMethod. </param>
		/// <param name="numSubSteps">The number of sub steps the time step will be divided into.</param>
		public virtual void getTiming(ref float maxTimestep, ref uint maxIter, ref NxTimeStepMethod method, uint[] numSubSteps)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_getTiming_INVOKE(ClassPointer, doSetFunctionPointers, ref maxTimestep, ref maxIter, ref method, numSubSteps);
		}
		
		private void getTiming_virtual([In()] [Out()] ref float maxTimestep, [In()] [Out()] ref uint maxIter, [In()] [Out()] ref NxTimeStepMethod method, uint[] numSubSteps)
		{
			getTiming(ref maxTimestep, ref maxIter, ref method, numSubSteps);
		}
		
		delegate void getTiming_188_delegate([In()] [Out()] ref float maxTimestep, [In()] [Out()] ref uint maxIter, [In()] [Out()] ref NxTimeStepMethod method, uint[] numSubSteps);
		
		
		
		
		
		
		private getTiming_188_delegate getTiming_188_delegatefield;
		
		/// <summary>Retrieves simulation timing parameters. </summary>
		/// <param name="maxTimestep">Maximum size to divide a substep into. Range: (0,inf) </param>
		/// <param name="maxIter">Maximum number of iterations to divide a timestep into. </param>
		/// <param name="method">Method to use for timestep (either variable time step or fixed). See NxTimeStepMethod. </param>
		/// <param name="numSubSteps">The number of sub steps the time step will be divided into.</param>
		public virtual void getTiming(ref float maxTimestep, ref uint maxIter, ref NxTimeStepMethod method)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_getTiming_1_INVOKE(ClassPointer, doSetFunctionPointers, ref maxTimestep, ref maxIter, ref method);
		}
		
		private void getTiming_virtual([In()] [Out()] ref float maxTimestep, [In()] [Out()] ref uint maxIter, [In()] [Out()] ref NxTimeStepMethod method)
		{
			getTiming(ref maxTimestep, ref maxIter, ref method);
		}
		
		delegate void getTiming_189_delegate([In()] [Out()] ref float maxTimestep, [In()] [Out()] ref uint maxIter, [In()] [Out()] ref NxTimeStepMethod method);
		
		
		
		
		
		
		private getTiming_189_delegate getTiming_189_delegatefield;
		
		/// <summary>Retrieves the debug renderable. </summary>
		public virtual NxDebugRenderable getDebugRenderable()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxDebugRenderable.GetClass(NxScene_getDebugRenderable_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getDebugRenderable_virtual()
		{
			return getDebugRenderable().ClassPointer.Handle;
		}
		
		delegate IntPtr getDebugRenderable_190_delegate();
		
		
		
		
		
		
		private getDebugRenderable_190_delegate getDebugRenderable_190_delegatefield;
		
		/// <summary>Call this method to retrieve the Physics SDK. </summary>
		public virtual NxPhysicsSDK getPhysicsSDK()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxPhysicsSDK.GetClass(NxScene_getPhysicsSDK_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getPhysicsSDK_virtual()
		{
			return getPhysicsSDK().ClassPointer.Handle;
		}
		
		delegate IntPtr getPhysicsSDK_191_delegate();
		
		
		
		
		
		
		private getPhysicsSDK_191_delegate getPhysicsSDK_191_delegatefield;
		
		/// <summary>Call this method to retrieve statistics about the current scene. </summary>
		/// <param name="stats">Used to retrieve statistics for the scene. See NxSceneStats.</param>
		public virtual void getStats(NxSceneStats stats)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_getStats_INVOKE(ClassPointer, doSetFunctionPointers, (stats!=null ? stats.ClassPointer : NullRef));
		}
		
		private void getStats_virtual(IntPtr stats)
		{
			getStats(NxSceneStats.GetClass(stats));
		}
		
		delegate void getStats_192_delegate(IntPtr stats);
		
		
		
		
		
		
		private getStats_192_delegate getStats_192_delegatefield;
		
		/// <summary>Call this method to retrieve extended statistics about the current scene. </summary>
		public virtual NxSceneStats2 getStats2()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxSceneStats2.GetClass(NxScene_getStats2_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getStats2_virtual()
		{
			return getStats2().ClassPointer.Handle;
		}
		
		delegate IntPtr getStats2_193_delegate();
		
		
		
		
		
		
		private getStats2_193_delegate getStats2_193_delegatefield;
		
		/// <summary>Call to retrieve the expected object count limits set in the scene descriptor. </summary>
		/// <param name="limits">Used to retrieve the limits for the scene(e.g. maximum number of actors). See NxSceneLimits.</param>
		public virtual void getLimits(NxSceneLimits limits)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_getLimits_INVOKE(ClassPointer, doSetFunctionPointers, (limits!=null ? limits.ClassPointer : NullRef));
		}
		
		private void getLimits_virtual(IntPtr limits)
		{
			getLimits(NxSceneLimits.GetClass(limits));
		}
		
		delegate void getLimits_194_delegate(IntPtr limits);
		
		
		
		
		
		
		private getLimits_194_delegate getLimits_194_delegatefield;
		
		/// <summary>Not yet implemented! </summary>
		/// <param name="cpuFraction">The maximum fraction of the total host CPU to use - for example 0.2 would equate to 20% of a single core or might use 10% of each core or 20% of one core on a dual-core CPU.</param>
		public virtual void setMaxCPUForLoadBalancing(float cpuFraction)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setMaxCPUForLoadBalancing_INVOKE(ClassPointer, doSetFunctionPointers, cpuFraction);
		}
		
		private void setMaxCPUForLoadBalancing_virtual(float cpuFraction)
		{
			setMaxCPUForLoadBalancing(cpuFraction);
		}
		
		delegate void setMaxCPUForLoadBalancing_195_delegate(float cpuFraction);
		
		
		
		
		
		
		private setMaxCPUForLoadBalancing_195_delegate setMaxCPUForLoadBalancing_195_delegatefield;
		
		/// <summary>Call to get the maximum CPU for use when load-balancing. </summary>
		public virtual float getMaxCPUForLoadBalancing()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getMaxCPUForLoadBalancing_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private float getMaxCPUForLoadBalancing_virtual()
		{
			return getMaxCPUForLoadBalancing();
		}
		
		delegate float getMaxCPUForLoadBalancing_196_delegate();
		
		
		
		
		
		
		private getMaxCPUForLoadBalancing_196_delegate getMaxCPUForLoadBalancing_196_delegatefield;
		
		/// <summary>This is a query to see if the scene is in a state that allows the application to update scene state. </summary>
		public virtual bool isWritable()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_isWritable_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private bool isWritable_virtual()
		{
			return isWritable();
		}
		
		delegate bool isWritable_197_delegate();
		
		
		
		
		
		
		private isWritable_197_delegate isWritable_197_delegatefield;
		
		/// <summary>Advances the simulation by an elapsedTime time. </summary>
		/// <param name="elapsedTime">Amount of time to advance simulation by. Range: (0,inf)</param>
		public virtual void simulate(float elapsedTime)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_simulate_INVOKE(ClassPointer, doSetFunctionPointers, elapsedTime);
		}
		
		private void simulate_virtual(float elapsedTime)
		{
			simulate(elapsedTime);
		}
		
		delegate void simulate_198_delegate(float elapsedTime);
		
		
		
		
		
		
		private simulate_198_delegate simulate_198_delegatefield;
		
		/// <summary>This checks to see if the part of the simulation run whose results you are interested in has completed. </summary>
		/// <param name="status">The part of the simulation to check (eg NX_RIGID_BODY_FINISHED). See NxSimulationStatus. </param>
		/// <param name="block">When set to true will block until the condition is met. </param>
		public virtual bool checkResults(NxSimulationStatus status, bool block)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkResults_INVOKE(ClassPointer, doSetFunctionPointers, status, block);
		}
		
		private bool checkResults_virtual(NxSimulationStatus status, bool block)
		{
			return checkResults(status, block);
		}
		
		delegate bool checkResults_199_delegate(NxSimulationStatus status, bool block);
		
		
		
		
		
		
		private checkResults_199_delegate checkResults_199_delegatefield;
		
		/// <summary>This checks to see if the part of the simulation run whose results you are interested in has completed. </summary>
		/// <param name="status">The part of the simulation to check (eg NX_RIGID_BODY_FINISHED). See NxSimulationStatus. </param>
		/// <param name="block">When set to true will block until the condition is met. </param>
		public virtual bool checkResults(NxSimulationStatus status)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_checkResults_1_INVOKE(ClassPointer, doSetFunctionPointers, status);
		}
		
		private bool checkResults_virtual(NxSimulationStatus status)
		{
			return checkResults(status);
		}
		
		delegate bool checkResults_200_delegate(NxSimulationStatus status);
		
		
		
		
		
		
		private checkResults_200_delegate checkResults_200_delegatefield;
		
		/// <summary></summary>
		/// <param name="status">The part of the simulation to fetch results for (eg NX_RIGID_BODY_FINISHED). See NxSimulationStatus. </param>
		/// <param name="block">When set to true will block until the condition is met. </param>
		/// <param name="errorState">Used to retrieve hardware error codes. A non zero value indicates an error. </param>
		public virtual bool fetchResults(NxSimulationStatus status, bool block, uint[] errorState)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_fetchResults_INVOKE(ClassPointer, doSetFunctionPointers, status, block, errorState);
		}
		
		private bool fetchResults_virtual(NxSimulationStatus status, bool block, uint[] errorState)
		{
			return fetchResults(status, block, errorState);
		}
		
		delegate bool fetchResults_201_delegate(NxSimulationStatus status, bool block, uint[] errorState);
		
		
		
		
		
		
		private fetchResults_201_delegate fetchResults_201_delegatefield;
		
		/// <summary></summary>
		/// <param name="status">The part of the simulation to fetch results for (eg NX_RIGID_BODY_FINISHED). See NxSimulationStatus. </param>
		/// <param name="block">When set to true will block until the condition is met. </param>
		/// <param name="errorState">Used to retrieve hardware error codes. A non zero value indicates an error. </param>
		public virtual bool fetchResults(NxSimulationStatus status, bool block)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_fetchResults_1_INVOKE(ClassPointer, doSetFunctionPointers, status, block);
		}
		
		private bool fetchResults_virtual(NxSimulationStatus status, bool block)
		{
			return fetchResults(status, block);
		}
		
		delegate bool fetchResults_202_delegate(NxSimulationStatus status, bool block);
		
		
		
		
		
		
		private fetchResults_202_delegate fetchResults_202_delegatefield;
		
		/// <summary></summary>
		/// <param name="status">The part of the simulation to fetch results for (eg NX_RIGID_BODY_FINISHED). See NxSimulationStatus. </param>
		/// <param name="block">When set to true will block until the condition is met. </param>
		/// <param name="errorState">Used to retrieve hardware error codes. A non zero value indicates an error. </param>
		public virtual bool fetchResults(NxSimulationStatus status)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_fetchResults_2_INVOKE(ClassPointer, doSetFunctionPointers, status);
		}
		
		private bool fetchResults_virtual(NxSimulationStatus status)
		{
			return fetchResults(status);
		}
		
		delegate bool fetchResults_203_delegate(NxSimulationStatus status);
		
		
		
		
		
		
		private fetchResults_203_delegate fetchResults_203_delegatefield;
		
		/// <summary></summary>
		public virtual void flushCaches()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_flushCaches_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void flushCaches_virtual()
		{
			flushCaches();
		}
		
		delegate void flushCaches_204_delegate();
		
		
		
		
		
		
		private flushCaches_204_delegate flushCaches_204_delegatefield;
		
		/// <summary></summary>
		public virtual NxProfileData readProfileData(bool clearData)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxProfileData.GetClass(NxScene_readProfileData_INVOKE(ClassPointer, doSetFunctionPointers, clearData));
		}
		
		private IntPtr readProfileData_virtual(bool clearData)
		{
			return readProfileData(clearData).ClassPointer.Handle;
		}
		
		delegate IntPtr readProfileData_205_delegate(bool clearData);
		
		
		
		
		
		
		private readProfileData_205_delegate readProfileData_205_delegatefield;
		
		/// <summary>Poll for work to execute on the current thread. </summary>
		/// <param name="waitType">Specifies how long the function should wait for work. </param>
		public virtual NxThreadPollResult pollForWork(NxThreadWait waitType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_pollForWork_INVOKE(ClassPointer, doSetFunctionPointers, waitType);
		}
		
		private NxThreadPollResult pollForWork_virtual(NxThreadWait waitType)
		{
			return pollForWork(waitType);
		}
		
		delegate NxThreadPollResult pollForWork_206_delegate(NxThreadWait waitType);
		
		
		
		
		
		
		private pollForWork_206_delegate pollForWork_206_delegatefield;
		
		/// <summary>Reset parallel simulation. </summary>
		public virtual void resetPollForWork()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_resetPollForWork_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void resetPollForWork_virtual()
		{
			resetPollForWork();
		}
		
		delegate void resetPollForWork_207_delegate();
		
		
		
		
		
		
		private resetPollForWork_207_delegate resetPollForWork_207_delegatefield;
		
		/// <summary>Polls for background work. </summary>
		/// <param name="waitType">Specifies how long the function should wait for work. </param>
		public virtual NxThreadPollResult pollForBackgroundWork(NxThreadWait waitType)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_pollForBackgroundWork_INVOKE(ClassPointer, doSetFunctionPointers, waitType);
		}
		
		private NxThreadPollResult pollForBackgroundWork_virtual(NxThreadWait waitType)
		{
			return pollForBackgroundWork(waitType);
		}
		
		delegate NxThreadPollResult pollForBackgroundWork_208_delegate(NxThreadWait waitType);
		
		
		
		
		
		
		private pollForBackgroundWork_208_delegate pollForBackgroundWork_208_delegatefield;
		
		/// <summary>Release threads which are blocking to allow the SDK to be destroyed safely. </summary>
		public virtual void shutdownWorkerThreads()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_shutdownWorkerThreads_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void shutdownWorkerThreads_virtual()
		{
			shutdownWorkerThreads();
		}
		
		delegate void shutdownWorkerThreads_209_delegate();
		
		
		
		
		
		
		private shutdownWorkerThreads_209_delegate shutdownWorkerThreads_209_delegatefield;
		
		/// <summary>Blocks all parallel raycast/overlap queries. </summary>
		public virtual void lockQueries()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_lockQueries_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void lockQueries_virtual()
		{
			lockQueries();
		}
		
		delegate void lockQueries_210_delegate();
		
		
		
		
		
		
		private lockQueries_210_delegate lockQueries_210_delegatefield;
		
		/// <summary>Unlock parallel raycast/overlap queries. </summary>
		public virtual void unlockQueries()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_unlockQueries_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void unlockQueries_virtual()
		{
			unlockQueries();
		}
		
		delegate void unlockQueries_211_delegate();
		
		
		
		
		
		
		private unlockQueries_211_delegate unlockQueries_211_delegatefield;
		
		/// <summary>Create a batched query object. </summary>
		/// <param name="desc">Descriptor used to modify the created query object. </param>
		public virtual NxSceneQuery createSceneQuery(NxSceneQueryDesc desc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxSceneQuery.GetClass(NxScene_createSceneQuery_INVOKE(ClassPointer, doSetFunctionPointers, (desc!=null ? desc.ClassPointer : NullRef)));
		}
		
		private IntPtr createSceneQuery_virtual(IntPtr desc)
		{
			return createSceneQuery(NxSceneQueryDesc.GetClass(desc)).ClassPointer.Handle;
		}
		
		delegate IntPtr createSceneQuery_212_delegate(IntPtr desc);
		
		
		
		
		
		
		private createSceneQuery_212_delegate createSceneQuery_212_delegatefield;
		
		/// <summary>Release a scene query object. </summary>
		/// <param name="query">The query object to release. </param>
		public virtual bool releaseSceneQuery(NxSceneQuery query)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_releaseSceneQuery_INVOKE(ClassPointer, doSetFunctionPointers, (query!=null ? query.ClassPointer : NullRef));
		}
		
		private bool releaseSceneQuery_virtual(IntPtr query)
		{
			return releaseSceneQuery(NxSceneQuery.GetClass(query));
		}
		
		delegate bool releaseSceneQuery_213_delegate(IntPtr query);
		
		
		
		
		
		
		private releaseSceneQuery_213_delegate releaseSceneQuery_213_delegatefield;
		
		/// <summary>Sets the rebuild rate of the dynamic tree pruning structure. </summary>
		/// <param name="dynamicTreeRebuildRateHint">Rebuild rate of the dynamic tree pruning structure.</param>
		public virtual void setDynamicTreeRebuildRateHint(uint dynamicTreeRebuildRateHint)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setDynamicTreeRebuildRateHint_INVOKE(ClassPointer, doSetFunctionPointers, dynamicTreeRebuildRateHint);
		}
		
		private void setDynamicTreeRebuildRateHint_virtual(uint dynamicTreeRebuildRateHint)
		{
			setDynamicTreeRebuildRateHint(dynamicTreeRebuildRateHint);
		}
		
		delegate void setDynamicTreeRebuildRateHint_214_delegate(uint dynamicTreeRebuildRateHint);
		
		
		
		
		
		
		private setDynamicTreeRebuildRateHint_214_delegate setDynamicTreeRebuildRateHint_214_delegatefield;
		
		/// <summary>Retrieves the rebuild rate of the dynamic tree pruning structure. </summary>
		public virtual uint getDynamicTreeRebuildRateHint()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getDynamicTreeRebuildRateHint_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getDynamicTreeRebuildRateHint_virtual()
		{
			return getDynamicTreeRebuildRateHint();
		}
		
		delegate uint getDynamicTreeRebuildRateHint_215_delegate();
		
		
		
		
		
		
		private getDynamicTreeRebuildRateHint_215_delegate getDynamicTreeRebuildRateHint_215_delegatefield;
		
		/// <summary>Sets the number of actors required to spawn a separate rigid body solver thread. </summary>
		/// <param name="solverBatchSize">Number of actors required to spawn a separate rigid body solver thread.</param>
		public virtual void setSolverBatchSize(uint solverBatchSize)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxScene_setSolverBatchSize_INVOKE(ClassPointer, doSetFunctionPointers, solverBatchSize);
		}
		
		private void setSolverBatchSize_virtual(uint solverBatchSize)
		{
			setSolverBatchSize(solverBatchSize);
		}
		
		delegate void setSolverBatchSize_216_delegate(uint solverBatchSize);
		
		
		
		
		
		
		private setSolverBatchSize_216_delegate setSolverBatchSize_216_delegatefield;
		
		/// <summary>Retrieves the number of actors required to spawn a separate rigid body solver thread. </summary>
		public virtual uint getSolverBatchSize()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxScene_getSolverBatchSize_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getSolverBatchSize_virtual()
		{
			return getSolverBatchSize();
		}
		
		delegate uint getSolverBatchSize_217_delegate();
		
		
		
		
		
		
		private getSolverBatchSize_217_delegate getSolverBatchSize_217_delegatefield;
		
		#region Imports
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createActor")]
        private extern static IntPtr NxScene_createActor_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef desc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseActor")]
        private extern static void NxScene_releaseActor_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef actor);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createJoint")]
        private extern static IntPtr NxScene_createJoint_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef jointDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseJoint")]
        private extern static void NxScene_releaseJoint_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef joint);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createSpringAndDamperEffector")]
        private extern static IntPtr NxScene_createSpringAndDamperEffector_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef springDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createEffector")]
        private extern static IntPtr NxScene_createEffector_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef desc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseEffector")]
        private extern static void NxScene_releaseEffector_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef effector);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createForceField")]
        private extern static IntPtr NxScene_createForceField_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef forceFieldDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseForceField")]
        private extern static void NxScene_releaseForceField_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef forceField);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbForceFields")]
        private extern static System.UInt32 NxScene_getNbForceFields_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getForceFields")]
        private extern static IntPtr[] NxScene_getForceFields_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createForceFieldLinearKernel")]
        private extern static IntPtr NxScene_createForceFieldLinearKernel_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef kernelDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseForceFieldLinearKernel")]
        private extern static void NxScene_releaseForceFieldLinearKernel_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef kernel);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbForceFieldLinearKernels")]
        private extern static System.UInt32 NxScene_getNbForceFieldLinearKernels_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_resetForceFieldLinearKernelsIterator")]
        private extern static void NxScene_resetForceFieldLinearKernelsIterator_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNextForceFieldLinearKernel")]
        private extern static IntPtr NxScene_getNextForceFieldLinearKernel_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createForceFieldShapeGroup")]
        private extern static IntPtr NxScene_createForceFieldShapeGroup_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef desc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseForceFieldShapeGroup")]
        private extern static void NxScene_releaseForceFieldShapeGroup_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef group);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbForceFieldShapeGroups")]
        private extern static System.UInt32 NxScene_getNbForceFieldShapeGroups_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_resetForceFieldShapeGroupsIterator")]
        private extern static void NxScene_resetForceFieldShapeGroupsIterator_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNextForceFieldShapeGroup")]
        private extern static IntPtr NxScene_getNextForceFieldShapeGroup_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createForceFieldVariety")]
        private extern static System.UInt16 NxScene_createForceFieldVariety_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getHighestForceFieldVariety")]
        private extern static System.UInt16 NxScene_getHighestForceFieldVariety_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseForceFieldVariety")]
        private extern static void NxScene_releaseForceFieldVariety_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 var);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createForceFieldMaterial")]
        private extern static System.UInt16 NxScene_createForceFieldMaterial_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getHighestForceFieldMaterial")]
        private extern static System.UInt16 NxScene_getHighestForceFieldMaterial_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseForceFieldMaterial")]
        private extern static void NxScene_releaseForceFieldMaterial_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 mat);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getForceFieldScale")]
        private extern static System.Single NxScene_getForceFieldScale_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 var, System.UInt16 mat);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setForceFieldScale")]
        private extern static void NxScene_setForceFieldScale_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 var, System.UInt16 mat, System.Single val);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createMaterial")]
        private extern static IntPtr NxScene_createMaterial_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef matDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseMaterial")]
        private extern static void NxScene_releaseMaterial_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef material);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createCompartment")]
        private extern static IntPtr NxScene_createCompartment_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef compDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbCompartments")]
        private extern static System.UInt32 NxScene_getNbCompartments_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getCompartmentArray")]
        private extern static System.UInt32 NxScene_getCompartmentArray_INVOKE (HandleRef classPointer, System.Boolean call_explicit, IntPtr[] userBuffer, System.UInt32 bufferSize, [In()] [Out()] ref System.UInt32 usersIterator);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setActorPairFlags")]
        private extern static void NxScene_setActorPairFlags_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef actorA, HandleRef actorB, System.UInt32 nxContactPairFlag);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getActorPairFlags")]
        private extern static System.UInt32 NxScene_getActorPairFlags_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef actorA, HandleRef actorB);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setShapePairFlags")]
        private extern static void NxScene_setShapePairFlags_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef shapeA, HandleRef shapeB, System.UInt32 nxContactPairFlag);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getShapePairFlags")]
        private extern static System.UInt32 NxScene_getShapePairFlags_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef shapeA, HandleRef shapeB);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbPairs")]
        private extern static System.UInt32 NxScene_getNbPairs_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getPairFlagArray")]
        private extern static System.UInt32 NxScene_getPairFlagArray_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef userArray, System.UInt32 numPairs);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setGroupCollisionFlag")]
        private extern static void NxScene_setGroupCollisionFlag_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 group1, System.UInt16 group2, System.Boolean enable);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getGroupCollisionFlag")]
        private extern static System.Boolean NxScene_getGroupCollisionFlag_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 group1, System.UInt16 group2);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setDominanceGroupPair")]
        private extern static void NxScene_setDominanceGroupPair_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 group1, System.UInt16 group2, HandleRef dominance);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getDominanceGroupPair")]
        private extern static IntPtr NxScene_getDominanceGroupPair_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 group1, System.UInt16 group2);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setActorGroupPairFlags")]
        private extern static void NxScene_setActorGroupPairFlags_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 group1, System.UInt16 group2, System.UInt32 flags);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getActorGroupPairFlags")]
        private extern static System.UInt32 NxScene_getActorGroupPairFlags_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 group1, System.UInt16 group2);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbActorGroupPairs")]
        private extern static System.UInt32 NxScene_getNbActorGroupPairs_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getActorGroupPairArray")]
        private extern static System.UInt32 NxScene_getActorGroupPairArray_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef userBuffer, System.UInt32 bufferSize, [In()] [Out()] ref System.UInt32 userIterator);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setFilterOps")]
        private extern static void NxScene_setFilterOps_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxFilterOp op0, NxFilterOp op1, NxFilterOp op2);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setFilterBool")]
        private extern static void NxScene_setFilterBool_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Boolean flag);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setFilterConstant0")]
        private extern static void NxScene_setFilterConstant0_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef mask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setFilterConstant1")]
        private extern static void NxScene_setFilterConstant1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef mask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getFilterOps")]
        private extern static void NxScene_getFilterOps_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] [Out()] ref NxFilterOp op0, [In()] [Out()] ref NxFilterOp op1, [In()] [Out()] ref NxFilterOp op2);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getFilterBool")]
        private extern static System.Boolean NxScene_getFilterBool_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getFilterConstant0")]
        private extern static IntPtr NxScene_getFilterConstant0_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getFilterConstant1")]
        private extern static IntPtr NxScene_getFilterConstant1_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbActors")]
        private extern static System.UInt32 NxScene_getNbActors_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getActors")]
        private extern static IntPtr[] NxScene_getActors_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getActiveTransforms")]
        private extern static IntPtr NxScene_getActiveTransforms_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] [Out()] ref System.UInt32 nbTransformsOut);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbStaticShapes")]
        private extern static System.UInt32 NxScene_getNbStaticShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbDynamicShapes")]
        private extern static System.UInt32 NxScene_getNbDynamicShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getTotalNbShapes")]
        private extern static System.UInt32 NxScene_getTotalNbShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbJoints")]
        private extern static System.UInt32 NxScene_getNbJoints_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_resetJointIterator")]
        private extern static void NxScene_resetJointIterator_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNextJoint")]
        private extern static IntPtr NxScene_getNextJoint_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbEffectors")]
        private extern static System.UInt32 NxScene_getNbEffectors_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_resetEffectorIterator")]
        private extern static void NxScene_resetEffectorIterator_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNextEffector")]
        private extern static IntPtr NxScene_getNextEffector_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getBoundForIslandSize")]
        private extern static System.UInt32 NxScene_getBoundForIslandSize_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef actor);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getIslandArrayFromActor")]
        private extern static System.UInt32 NxScene_getIslandArrayFromActor_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef actor, IntPtr[] userBuffer, System.UInt32 bufferSize, [In()] [Out()] ref System.UInt32 userIterator);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbMaterials")]
        private extern static System.UInt32 NxScene_getNbMaterials_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getMaterialArray")]
        private extern static System.UInt32 NxScene_getMaterialArray_INVOKE (HandleRef classPointer, System.Boolean call_explicit, IntPtr[] userBuffer, System.UInt32 bufferSize, [In()] [Out()] ref System.UInt32 usersIterator);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getHighestMaterialIndex")]
        private extern static System.UInt16 NxScene_getHighestMaterialIndex_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getMaterialFromIndex")]
        private extern static IntPtr NxScene_getMaterialFromIndex_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt16 matIndex);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setUserNotify")]
        private extern static void NxScene_setUserNotify_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getUserNotify")]
        private extern static IntPtr NxScene_getUserNotify_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setFluidUserNotify")]
        private extern static void NxScene_setFluidUserNotify_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getFluidUserNotify")]
        private extern static IntPtr NxScene_getFluidUserNotify_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setClothUserNotify")]
        private extern static void NxScene_setClothUserNotify_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getClothUserNotify")]
        private extern static IntPtr NxScene_getClothUserNotify_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setSoftBodyUserNotify")]
        private extern static void NxScene_setSoftBodyUserNotify_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getSoftBodyUserNotify")]
        private extern static IntPtr NxScene_getSoftBodyUserNotify_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setUserContactModify")]
        private extern static void NxScene_setUserContactModify_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getUserContactModify")]
        private extern static IntPtr NxScene_getUserContactModify_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setUserTriggerReport")]
        private extern static void NxScene_setUserTriggerReport_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getUserTriggerReport")]
        private extern static IntPtr NxScene_getUserTriggerReport_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setUserContactReport")]
        private extern static void NxScene_setUserContactReport_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getUserContactReport")]
        private extern static IntPtr NxScene_getUserContactReport_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setUserActorPairFiltering")]
        private extern static void NxScene_setUserActorPairFiltering_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getUserActorPairFiltering")]
        private extern static IntPtr NxScene_getUserActorPairFiltering_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyBounds")]
        private extern static System.Boolean NxScene_raycastAnyBounds_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyBounds_1")]
        private extern static System.Boolean NxScene_raycastAnyBounds_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyBounds_2")]
        private extern static System.Boolean NxScene_raycastAnyBounds_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType, System.UInt32 groups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyBounds_3")]
        private extern static System.Boolean NxScene_raycastAnyBounds_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyShape")]
        private extern static System.Boolean NxScene_raycastAnyShape_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist, HandleRef groupsMask, IntPtr[] cache);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyShape_1")]
        private extern static System.Boolean NxScene_raycastAnyShape_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyShape_2")]
        private extern static System.Boolean NxScene_raycastAnyShape_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyShape_3")]
        private extern static System.Boolean NxScene_raycastAnyShape_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType, System.UInt32 groups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAnyShape_4")]
        private extern static System.Boolean NxScene_raycastAnyShape_4_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapesType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllBounds")]
        private extern static System.UInt32 NxScene_raycastAllBounds_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllBounds_1")]
        private extern static System.UInt32 NxScene_raycastAllBounds_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllBounds_2")]
        private extern static System.UInt32 NxScene_raycastAllBounds_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllBounds_3")]
        private extern static System.UInt32 NxScene_raycastAllBounds_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType, System.UInt32 groups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllBounds_4")]
        private extern static System.UInt32 NxScene_raycastAllBounds_4_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllShapes")]
        private extern static System.UInt32 NxScene_raycastAllShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllShapes_1")]
        private extern static System.UInt32 NxScene_raycastAllShapes_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllShapes_2")]
        private extern static System.UInt32 NxScene_raycastAllShapes_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType, System.UInt32 groups, System.Single maxDist);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllShapes_3")]
        private extern static System.UInt32 NxScene_raycastAllShapes_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType, System.UInt32 groups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastAllShapes_4")]
        private extern static System.UInt32 NxScene_raycastAllShapes_4_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, HandleRef report, NxShapesType shapesType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestBounds")]
        private extern static IntPtr NxScene_raycastClosestBounds_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestBounds_1")]
        private extern static IntPtr NxScene_raycastClosestBounds_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestBounds_2")]
        private extern static IntPtr NxScene_raycastClosestBounds_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups, System.Single maxDist);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestBounds_3")]
        private extern static IntPtr NxScene_raycastClosestBounds_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestBounds_4")]
        private extern static IntPtr NxScene_raycastClosestBounds_4_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestShape")]
        private extern static IntPtr NxScene_raycastClosestShape_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags, HandleRef groupsMask, IntPtr[] cache);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestShape_1")]
        private extern static IntPtr NxScene_raycastClosestShape_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestShape_2")]
        private extern static IntPtr NxScene_raycastClosestShape_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups, System.Single maxDist, System.UInt32 hintFlags);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestShape_3")]
        private extern static IntPtr NxScene_raycastClosestShape_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups, System.Single maxDist);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestShape_4")]
        private extern static IntPtr NxScene_raycastClosestShape_4_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit, System.UInt32 groups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_raycastClosestShape_5")]
        private extern static IntPtr NxScene_raycastClosestShape_5_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldRay, NxShapesType shapeType, HandleRef hit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapSphereShapes")]
        private extern static System.UInt32 NxScene_overlapSphereShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldSphere, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask, System.Boolean accurateCollision);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapSphereShapes_1")]
        private extern static System.UInt32 NxScene_overlapSphereShapes_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldSphere, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapSphereShapes_2")]
        private extern static System.UInt32 NxScene_overlapSphereShapes_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldSphere, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapSphereShapes_3")]
        private extern static System.UInt32 NxScene_overlapSphereShapes_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldSphere, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapAABBShapes")]
        private extern static System.UInt32 NxScene_overlapAABBShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBounds, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask, System.Boolean accurateCollision);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapAABBShapes_1")]
        private extern static System.UInt32 NxScene_overlapAABBShapes_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBounds, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapAABBShapes_2")]
        private extern static System.UInt32 NxScene_overlapAABBShapes_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBounds, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapAABBShapes_3")]
        private extern static System.UInt32 NxScene_overlapAABBShapes_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBounds, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapOBBShapes")]
        private extern static System.UInt32 NxScene_overlapOBBShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask, System.Boolean accurateCollision);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapOBBShapes_1")]
        private extern static System.UInt32 NxScene_overlapOBBShapes_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapOBBShapes_2")]
        private extern static System.UInt32 NxScene_overlapOBBShapes_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapOBBShapes_3")]
        private extern static System.UInt32 NxScene_overlapOBBShapes_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapCapsuleShapes")]
        private extern static System.UInt32 NxScene_overlapCapsuleShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask, System.Boolean accurateCollision);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapCapsuleShapes_1")]
        private extern static System.UInt32 NxScene_overlapCapsuleShapes_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapCapsuleShapes_2")]
        private extern static System.UInt32 NxScene_overlapCapsuleShapes_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_overlapCapsuleShapes_3")]
        private extern static System.UInt32 NxScene_overlapCapsuleShapes_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createSweepCache")]
        private extern static IntPtr NxScene_createSweepCache_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseSweepCache")]
        private extern static void NxScene_releaseSweepCache_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef cache);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_linearOBBSweep")]
        private extern static System.UInt32 NxScene_linearOBBSweep_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, [In()] ref NxVec3 motion, System.UInt32 flags, System.IntPtr userData, System.UInt32 nbShapes, HandleRef shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_linearOBBSweep_1")]
        private extern static System.UInt32 NxScene_linearOBBSweep_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, [In()] ref NxVec3 motion, System.UInt32 flags, System.IntPtr userData, System.UInt32 nbShapes, HandleRef shapes, HandleRef callback, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_linearOBBSweep_2")]
        private extern static System.UInt32 NxScene_linearOBBSweep_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, [In()] ref NxVec3 motion, System.UInt32 flags, System.IntPtr userData, System.UInt32 nbShapes, HandleRef shapes, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_linearCapsuleSweep")]
        private extern static System.UInt32 NxScene_linearCapsuleSweep_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, [In()] ref NxVec3 motion, System.UInt32 flags, System.IntPtr userData, System.UInt32 nbShapes, HandleRef shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_linearCapsuleSweep_1")]
        private extern static System.UInt32 NxScene_linearCapsuleSweep_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, [In()] ref NxVec3 motion, System.UInt32 flags, System.IntPtr userData, System.UInt32 nbShapes, HandleRef shapes, HandleRef callback, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_linearCapsuleSweep_2")]
        private extern static System.UInt32 NxScene_linearCapsuleSweep_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, [In()] ref NxVec3 motion, System.UInt32 flags, System.IntPtr userData, System.UInt32 nbShapes, HandleRef shapes, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_cullShapes")]
        private extern static System.UInt32 NxScene_cullShapes_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt32 nbPlanes, HandleRef worldPlanes, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_cullShapes_1")]
        private extern static System.UInt32 NxScene_cullShapes_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt32 nbPlanes, HandleRef worldPlanes, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_cullShapes_2")]
        private extern static System.UInt32 NxScene_cullShapes_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt32 nbPlanes, HandleRef worldPlanes, NxShapesType shapeType, System.UInt32 nbShapes, IntPtr[] shapes, HandleRef callback);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapSphere")]
        private extern static System.Boolean NxScene_checkOverlapSphere_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldSphere, NxShapesType shapeType, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapSphere_1")]
        private extern static System.Boolean NxScene_checkOverlapSphere_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldSphere, NxShapesType shapeType, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapSphere_2")]
        private extern static System.Boolean NxScene_checkOverlapSphere_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldSphere, NxShapesType shapeType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapSphere_3")]
        private extern static System.Boolean NxScene_checkOverlapSphere_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldSphere);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapAABB")]
        private extern static System.Boolean NxScene_checkOverlapAABB_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBounds, NxShapesType shapeType, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapAABB_1")]
        private extern static System.Boolean NxScene_checkOverlapAABB_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBounds, NxShapesType shapeType, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapAABB_2")]
        private extern static System.Boolean NxScene_checkOverlapAABB_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBounds, NxShapesType shapeType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapAABB_3")]
        private extern static System.Boolean NxScene_checkOverlapAABB_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBounds);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapOBB")]
        private extern static System.Boolean NxScene_checkOverlapOBB_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, NxShapesType shapeType, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapOBB_1")]
        private extern static System.Boolean NxScene_checkOverlapOBB_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, NxShapesType shapeType, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapOBB_2")]
        private extern static System.Boolean NxScene_checkOverlapOBB_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox, NxShapesType shapeType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapOBB_3")]
        private extern static System.Boolean NxScene_checkOverlapOBB_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldBox);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapCapsule")]
        private extern static System.Boolean NxScene_checkOverlapCapsule_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, NxShapesType shapeType, System.UInt32 activeGroups, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapCapsule_1")]
        private extern static System.Boolean NxScene_checkOverlapCapsule_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, NxShapesType shapeType, System.UInt32 activeGroups);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapCapsule_2")]
        private extern static System.Boolean NxScene_checkOverlapCapsule_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule, NxShapesType shapeType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkOverlapCapsule_3")]
        private extern static System.Boolean NxScene_checkOverlapCapsule_3_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef worldCapsule);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createFluid")]
        private extern static IntPtr NxScene_createFluid_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef fluidDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseFluid")]
        private extern static void NxScene_releaseFluid_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef fluid);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbFluids")]
        private extern static System.UInt32 NxScene_getNbFluids_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getFluids")]
        private extern static IntPtr[] NxScene_getFluids_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_cookFluidMeshHotspot")]
        private extern static System.Boolean NxScene_cookFluidMeshHotspot_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef bounds, System.UInt32 packetSizeMultiplier, System.Single restParticlesPerMeter, System.Single kernelRadiusMultiplier, System.Single motionLimitMultiplier, System.Single collisionDistanceMultiplier, HandleRef compartment, System.Boolean forceStrictCookingFormat);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_cookFluidMeshHotspot_1")]
        private extern static System.Boolean NxScene_cookFluidMeshHotspot_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef bounds, System.UInt32 packetSizeMultiplier, System.Single restParticlesPerMeter, System.Single kernelRadiusMultiplier, System.Single motionLimitMultiplier, System.Single collisionDistanceMultiplier, HandleRef compartment);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_cookFluidMeshHotspot_2")]
        private extern static System.Boolean NxScene_cookFluidMeshHotspot_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef bounds, System.UInt32 packetSizeMultiplier, System.Single restParticlesPerMeter, System.Single kernelRadiusMultiplier, System.Single motionLimitMultiplier, System.Single collisionDistanceMultiplier);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createCloth")]
        private extern static IntPtr NxScene_createCloth_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef clothDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseCloth")]
        private extern static void NxScene_releaseCloth_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef cloth);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbCloths")]
        private extern static System.UInt32 NxScene_getNbCloths_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getCloths")]
        private extern static IntPtr[] NxScene_getCloths_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createSoftBody")]
        private extern static IntPtr NxScene_createSoftBody_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef softBodyDesc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseSoftBody")]
        private extern static void NxScene_releaseSoftBody_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef softBody);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getNbSoftBodies")]
        private extern static System.UInt32 NxScene_getNbSoftBodies_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getSoftBodies")]
        private extern static IntPtr[] NxScene_getSoftBodies_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="set_NxScene_userData")]
        private extern static void set_NxScene_userData_INVOKE (HandleRef classPointer, System.IntPtr newvalue);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="get_NxScene_userData")]
        private extern static System.IntPtr get_NxScene_userData_INVOKE (HandleRef classPointer);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="set_NxScene_extLink")]
        private extern static void set_NxScene_extLink_INVOKE (HandleRef classPointer, System.IntPtr newvalue);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="get_NxScene_extLink")]
        private extern static System.IntPtr get_NxScene_extLink_INVOKE (HandleRef classPointer);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="new_NxScene")]
        private extern static IntPtr new_NxScene_INVOKE (System.Boolean do_override);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_saveToDesc")]
        private extern static System.Boolean NxScene_saveToDesc_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef desc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getFlags")]
        private extern static System.UInt32 NxScene_getFlags_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getSimType")]
        private extern static NxSimulationType NxScene_getSimType_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getInternal")]
        private extern static System.IntPtr NxScene_getInternal_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setGravity")]
        private extern static void NxScene_setGravity_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] ref NxVec3 vec);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getGravity")]
        private extern static void NxScene_getGravity_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] [Out()] ref NxVec3 vec);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_flushStream")]
        private extern static void NxScene_flushStream_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setTiming")]
        private extern static void NxScene_setTiming_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Single maxTimestep, System.UInt32 maxIter, NxTimeStepMethod method);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setTiming_1")]
        private extern static void NxScene_setTiming_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Single maxTimestep, System.UInt32 maxIter);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setTiming_2")]
        private extern static void NxScene_setTiming_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Single maxTimestep);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getTiming")]
        private extern static void NxScene_getTiming_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] [Out()] ref System.Single maxTimestep, [In()] [Out()] ref System.UInt32 maxIter, [In()] [Out()] ref NxTimeStepMethod method, System.UInt32[] numSubSteps);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getTiming_1")]
        private extern static void NxScene_getTiming_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] [Out()] ref System.Single maxTimestep, [In()] [Out()] ref System.UInt32 maxIter, [In()] [Out()] ref NxTimeStepMethod method);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getDebugRenderable")]
        private extern static IntPtr NxScene_getDebugRenderable_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getPhysicsSDK")]
        private extern static IntPtr NxScene_getPhysicsSDK_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getStats")]
        private extern static void NxScene_getStats_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef stats);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getStats2")]
        private extern static IntPtr NxScene_getStats2_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getLimits")]
        private extern static void NxScene_getLimits_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef limits);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setMaxCPUForLoadBalancing")]
        private extern static void NxScene_setMaxCPUForLoadBalancing_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Single cpuFraction);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getMaxCPUForLoadBalancing")]
        private extern static System.Single NxScene_getMaxCPUForLoadBalancing_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_isWritable")]
        private extern static System.Boolean NxScene_isWritable_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_simulate")]
        private extern static void NxScene_simulate_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Single elapsedTime);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkResults")]
        private extern static System.Boolean NxScene_checkResults_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxSimulationStatus status, System.Boolean block);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_checkResults_1")]
        private extern static System.Boolean NxScene_checkResults_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxSimulationStatus status);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_fetchResults")]
        private extern static System.Boolean NxScene_fetchResults_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxSimulationStatus status, System.Boolean block, System.UInt32[] errorState);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_fetchResults_1")]
        private extern static System.Boolean NxScene_fetchResults_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxSimulationStatus status, System.Boolean block);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_fetchResults_2")]
        private extern static System.Boolean NxScene_fetchResults_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxSimulationStatus status);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_flushCaches")]
        private extern static void NxScene_flushCaches_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_readProfileData")]
        private extern static IntPtr NxScene_readProfileData_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Boolean clearData);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_pollForWork")]
        private extern static NxThreadPollResult NxScene_pollForWork_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxThreadWait waitType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_resetPollForWork")]
        private extern static void NxScene_resetPollForWork_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_pollForBackgroundWork")]
        private extern static NxThreadPollResult NxScene_pollForBackgroundWork_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxThreadWait waitType);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_shutdownWorkerThreads")]
        private extern static void NxScene_shutdownWorkerThreads_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_lockQueries")]
        private extern static void NxScene_lockQueries_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_unlockQueries")]
        private extern static void NxScene_unlockQueries_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_createSceneQuery")]
        private extern static IntPtr NxScene_createSceneQuery_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef desc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_releaseSceneQuery")]
        private extern static System.Boolean NxScene_releaseSceneQuery_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef query);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setDynamicTreeRebuildRateHint")]
        private extern static void NxScene_setDynamicTreeRebuildRateHint_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt32 dynamicTreeRebuildRateHint);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getDynamicTreeRebuildRateHint")]
        private extern static System.UInt32 NxScene_getDynamicTreeRebuildRateHint_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_setSolverBatchSize")]
        private extern static void NxScene_setSolverBatchSize_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.UInt32 solverBatchSize);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxScene_getSolverBatchSize")]
        private extern static System.UInt32 NxScene_getSolverBatchSize_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		#endregion
		
		private static System.Collections.Generic.Dictionary<System.IntPtr, System.WeakReference> database = new System.Collections.Generic.Dictionary<System.IntPtr, System.WeakReference>();
		
		protected override void SetPointer(IntPtr ptr)
		{
			base.SetPointer(ptr);
			database[ptr] = new WeakReference(this);
		}
		
		public override void Dispose()
		{
			database.Remove(ClassPointer.Handle);
			base.Dispose();
		}
		
		public static NxScene GetClass(IntPtr ptr)
		{
			if ((ptr == IntPtr.Zero))
			{
				return null;
			}
			System.WeakReference obj;
			if (database.TryGetValue(ptr, out obj))
			{
				if (obj.IsAlive)
				{
					return ((NxScene)(obj.Target));
				}
			}
			return new NxScene(ptr);
		}
		
		protected override System.Collections.Generic.List<System.IntPtr> CreateFunctionPointers()
		{
			System.Collections.Generic.List<System.IntPtr> list = base.CreateFunctionPointers();
			createActor_0_delegatefield = new createActor_0_delegate(this.createActor_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createActor_0_delegatefield));
			releaseActor_1_delegatefield = new releaseActor_1_delegate(this.releaseActor_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseActor_1_delegatefield));
			createJoint_2_delegatefield = new createJoint_2_delegate(this.createJoint_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createJoint_2_delegatefield));
			releaseJoint_3_delegatefield = new releaseJoint_3_delegate(this.releaseJoint_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseJoint_3_delegatefield));
			createSpringAndDamperEffector_4_delegatefield = new createSpringAndDamperEffector_4_delegate(this.createSpringAndDamperEffector_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createSpringAndDamperEffector_4_delegatefield));
			createEffector_5_delegatefield = new createEffector_5_delegate(this.createEffector_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createEffector_5_delegatefield));
			releaseEffector_6_delegatefield = new releaseEffector_6_delegate(this.releaseEffector_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseEffector_6_delegatefield));
			createForceField_7_delegatefield = new createForceField_7_delegate(this.createForceField_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createForceField_7_delegatefield));
			releaseForceField_8_delegatefield = new releaseForceField_8_delegate(this.releaseForceField_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseForceField_8_delegatefield));
			getNbForceFields_9_delegatefield = new getNbForceFields_9_delegate(this.getNbForceFields_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbForceFields_9_delegatefield));
			getForceFields_10_delegatefield = new getForceFields_10_delegate(this.getForceFields_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getForceFields_10_delegatefield));
			createForceFieldLinearKernel_11_delegatefield = new createForceFieldLinearKernel_11_delegate(this.createForceFieldLinearKernel_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createForceFieldLinearKernel_11_delegatefield));
			releaseForceFieldLinearKernel_12_delegatefield = new releaseForceFieldLinearKernel_12_delegate(this.releaseForceFieldLinearKernel_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseForceFieldLinearKernel_12_delegatefield));
			getNbForceFieldLinearKernels_13_delegatefield = new getNbForceFieldLinearKernels_13_delegate(this.getNbForceFieldLinearKernels_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbForceFieldLinearKernels_13_delegatefield));
			resetForceFieldLinearKernelsIterator_14_delegatefield = new resetForceFieldLinearKernelsIterator_14_delegate(this.resetForceFieldLinearKernelsIterator_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(resetForceFieldLinearKernelsIterator_14_delegatefield));
			getNextForceFieldLinearKernel_15_delegatefield = new getNextForceFieldLinearKernel_15_delegate(this.getNextForceFieldLinearKernel_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNextForceFieldLinearKernel_15_delegatefield));
			createForceFieldShapeGroup_16_delegatefield = new createForceFieldShapeGroup_16_delegate(this.createForceFieldShapeGroup_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createForceFieldShapeGroup_16_delegatefield));
			releaseForceFieldShapeGroup_17_delegatefield = new releaseForceFieldShapeGroup_17_delegate(this.releaseForceFieldShapeGroup_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseForceFieldShapeGroup_17_delegatefield));
			getNbForceFieldShapeGroups_18_delegatefield = new getNbForceFieldShapeGroups_18_delegate(this.getNbForceFieldShapeGroups_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbForceFieldShapeGroups_18_delegatefield));
			resetForceFieldShapeGroupsIterator_19_delegatefield = new resetForceFieldShapeGroupsIterator_19_delegate(this.resetForceFieldShapeGroupsIterator_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(resetForceFieldShapeGroupsIterator_19_delegatefield));
			getNextForceFieldShapeGroup_20_delegatefield = new getNextForceFieldShapeGroup_20_delegate(this.getNextForceFieldShapeGroup_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNextForceFieldShapeGroup_20_delegatefield));
			createForceFieldVariety_21_delegatefield = new createForceFieldVariety_21_delegate(this.createForceFieldVariety_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createForceFieldVariety_21_delegatefield));
			getHighestForceFieldVariety_22_delegatefield = new getHighestForceFieldVariety_22_delegate(this.getHighestForceFieldVariety_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getHighestForceFieldVariety_22_delegatefield));
			releaseForceFieldVariety_23_delegatefield = new releaseForceFieldVariety_23_delegate(this.releaseForceFieldVariety_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseForceFieldVariety_23_delegatefield));
			createForceFieldMaterial_24_delegatefield = new createForceFieldMaterial_24_delegate(this.createForceFieldMaterial_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createForceFieldMaterial_24_delegatefield));
			getHighestForceFieldMaterial_25_delegatefield = new getHighestForceFieldMaterial_25_delegate(this.getHighestForceFieldMaterial_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getHighestForceFieldMaterial_25_delegatefield));
			releaseForceFieldMaterial_26_delegatefield = new releaseForceFieldMaterial_26_delegate(this.releaseForceFieldMaterial_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseForceFieldMaterial_26_delegatefield));
			getForceFieldScale_27_delegatefield = new getForceFieldScale_27_delegate(this.getForceFieldScale_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getForceFieldScale_27_delegatefield));
			setForceFieldScale_28_delegatefield = new setForceFieldScale_28_delegate(this.setForceFieldScale_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setForceFieldScale_28_delegatefield));
			createMaterial_29_delegatefield = new createMaterial_29_delegate(this.createMaterial_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createMaterial_29_delegatefield));
			releaseMaterial_30_delegatefield = new releaseMaterial_30_delegate(this.releaseMaterial_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseMaterial_30_delegatefield));
			createCompartment_31_delegatefield = new createCompartment_31_delegate(this.createCompartment_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createCompartment_31_delegatefield));
			getNbCompartments_32_delegatefield = new getNbCompartments_32_delegate(this.getNbCompartments_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbCompartments_32_delegatefield));
			getCompartmentArray_33_delegatefield = new getCompartmentArray_33_delegate(this.getCompartmentArray_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getCompartmentArray_33_delegatefield));
			setActorPairFlags_34_delegatefield = new setActorPairFlags_34_delegate(this.setActorPairFlags_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setActorPairFlags_34_delegatefield));
			getActorPairFlags_35_delegatefield = new getActorPairFlags_35_delegate(this.getActorPairFlags_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getActorPairFlags_35_delegatefield));
			setShapePairFlags_36_delegatefield = new setShapePairFlags_36_delegate(this.setShapePairFlags_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setShapePairFlags_36_delegatefield));
			getShapePairFlags_37_delegatefield = new getShapePairFlags_37_delegate(this.getShapePairFlags_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getShapePairFlags_37_delegatefield));
			getNbPairs_38_delegatefield = new getNbPairs_38_delegate(this.getNbPairs_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbPairs_38_delegatefield));
			getPairFlagArray_39_delegatefield = new getPairFlagArray_39_delegate(this.getPairFlagArray_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getPairFlagArray_39_delegatefield));
			setGroupCollisionFlag_40_delegatefield = new setGroupCollisionFlag_40_delegate(this.setGroupCollisionFlag_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setGroupCollisionFlag_40_delegatefield));
			getGroupCollisionFlag_41_delegatefield = new getGroupCollisionFlag_41_delegate(this.getGroupCollisionFlag_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getGroupCollisionFlag_41_delegatefield));
			setDominanceGroupPair_42_delegatefield = new setDominanceGroupPair_42_delegate(this.setDominanceGroupPair_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setDominanceGroupPair_42_delegatefield));
			getDominanceGroupPair_43_delegatefield = new getDominanceGroupPair_43_delegate(this.getDominanceGroupPair_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getDominanceGroupPair_43_delegatefield));
			setActorGroupPairFlags_44_delegatefield = new setActorGroupPairFlags_44_delegate(this.setActorGroupPairFlags_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setActorGroupPairFlags_44_delegatefield));
			getActorGroupPairFlags_45_delegatefield = new getActorGroupPairFlags_45_delegate(this.getActorGroupPairFlags_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getActorGroupPairFlags_45_delegatefield));
			getNbActorGroupPairs_46_delegatefield = new getNbActorGroupPairs_46_delegate(this.getNbActorGroupPairs_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbActorGroupPairs_46_delegatefield));
			getActorGroupPairArray_47_delegatefield = new getActorGroupPairArray_47_delegate(this.getActorGroupPairArray_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getActorGroupPairArray_47_delegatefield));
			setFilterOps_48_delegatefield = new setFilterOps_48_delegate(this.setFilterOps_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setFilterOps_48_delegatefield));
			setFilterBool_49_delegatefield = new setFilterBool_49_delegate(this.setFilterBool_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setFilterBool_49_delegatefield));
			setFilterConstant0_50_delegatefield = new setFilterConstant0_50_delegate(this.setFilterConstant0_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setFilterConstant0_50_delegatefield));
			setFilterConstant1_51_delegatefield = new setFilterConstant1_51_delegate(this.setFilterConstant1_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setFilterConstant1_51_delegatefield));
			getFilterOps_52_delegatefield = new getFilterOps_52_delegate(this.getFilterOps_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getFilterOps_52_delegatefield));
			getFilterBool_53_delegatefield = new getFilterBool_53_delegate(this.getFilterBool_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getFilterBool_53_delegatefield));
			getFilterConstant0_54_delegatefield = new getFilterConstant0_54_delegate(this.getFilterConstant0_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getFilterConstant0_54_delegatefield));
			getFilterConstant1_55_delegatefield = new getFilterConstant1_55_delegate(this.getFilterConstant1_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getFilterConstant1_55_delegatefield));
			getNbActors_56_delegatefield = new getNbActors_56_delegate(this.getNbActors_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbActors_56_delegatefield));
			getActors_57_delegatefield = new getActors_57_delegate(this.getActors_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getActors_57_delegatefield));
			getActiveTransforms_58_delegatefield = new getActiveTransforms_58_delegate(this.getActiveTransforms_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getActiveTransforms_58_delegatefield));
			getNbStaticShapes_59_delegatefield = new getNbStaticShapes_59_delegate(this.getNbStaticShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbStaticShapes_59_delegatefield));
			getNbDynamicShapes_60_delegatefield = new getNbDynamicShapes_60_delegate(this.getNbDynamicShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbDynamicShapes_60_delegatefield));
			getTotalNbShapes_61_delegatefield = new getTotalNbShapes_61_delegate(this.getTotalNbShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getTotalNbShapes_61_delegatefield));
			getNbJoints_62_delegatefield = new getNbJoints_62_delegate(this.getNbJoints_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbJoints_62_delegatefield));
			resetJointIterator_63_delegatefield = new resetJointIterator_63_delegate(this.resetJointIterator_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(resetJointIterator_63_delegatefield));
			getNextJoint_64_delegatefield = new getNextJoint_64_delegate(this.getNextJoint_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNextJoint_64_delegatefield));
			getNbEffectors_65_delegatefield = new getNbEffectors_65_delegate(this.getNbEffectors_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbEffectors_65_delegatefield));
			resetEffectorIterator_66_delegatefield = new resetEffectorIterator_66_delegate(this.resetEffectorIterator_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(resetEffectorIterator_66_delegatefield));
			getNextEffector_67_delegatefield = new getNextEffector_67_delegate(this.getNextEffector_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNextEffector_67_delegatefield));
			getBoundForIslandSize_68_delegatefield = new getBoundForIslandSize_68_delegate(this.getBoundForIslandSize_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getBoundForIslandSize_68_delegatefield));
			getIslandArrayFromActor_69_delegatefield = new getIslandArrayFromActor_69_delegate(this.getIslandArrayFromActor_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getIslandArrayFromActor_69_delegatefield));
			getNbMaterials_70_delegatefield = new getNbMaterials_70_delegate(this.getNbMaterials_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbMaterials_70_delegatefield));
			getMaterialArray_71_delegatefield = new getMaterialArray_71_delegate(this.getMaterialArray_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getMaterialArray_71_delegatefield));
			getHighestMaterialIndex_72_delegatefield = new getHighestMaterialIndex_72_delegate(this.getHighestMaterialIndex_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getHighestMaterialIndex_72_delegatefield));
			getMaterialFromIndex_73_delegatefield = new getMaterialFromIndex_73_delegate(this.getMaterialFromIndex_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getMaterialFromIndex_73_delegatefield));
			setUserNotify_74_delegatefield = new setUserNotify_74_delegate(this.setUserNotify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setUserNotify_74_delegatefield));
			getUserNotify_75_delegatefield = new getUserNotify_75_delegate(this.getUserNotify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getUserNotify_75_delegatefield));
			setFluidUserNotify_76_delegatefield = new setFluidUserNotify_76_delegate(this.setFluidUserNotify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setFluidUserNotify_76_delegatefield));
			getFluidUserNotify_77_delegatefield = new getFluidUserNotify_77_delegate(this.getFluidUserNotify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getFluidUserNotify_77_delegatefield));
			setClothUserNotify_78_delegatefield = new setClothUserNotify_78_delegate(this.setClothUserNotify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setClothUserNotify_78_delegatefield));
			getClothUserNotify_79_delegatefield = new getClothUserNotify_79_delegate(this.getClothUserNotify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getClothUserNotify_79_delegatefield));
			setSoftBodyUserNotify_80_delegatefield = new setSoftBodyUserNotify_80_delegate(this.setSoftBodyUserNotify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setSoftBodyUserNotify_80_delegatefield));
			getSoftBodyUserNotify_81_delegatefield = new getSoftBodyUserNotify_81_delegate(this.getSoftBodyUserNotify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getSoftBodyUserNotify_81_delegatefield));
			setUserContactModify_82_delegatefield = new setUserContactModify_82_delegate(this.setUserContactModify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setUserContactModify_82_delegatefield));
			getUserContactModify_83_delegatefield = new getUserContactModify_83_delegate(this.getUserContactModify_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getUserContactModify_83_delegatefield));
			setUserTriggerReport_84_delegatefield = new setUserTriggerReport_84_delegate(this.setUserTriggerReport_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setUserTriggerReport_84_delegatefield));
			getUserTriggerReport_85_delegatefield = new getUserTriggerReport_85_delegate(this.getUserTriggerReport_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getUserTriggerReport_85_delegatefield));
			setUserContactReport_86_delegatefield = new setUserContactReport_86_delegate(this.setUserContactReport_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setUserContactReport_86_delegatefield));
			getUserContactReport_87_delegatefield = new getUserContactReport_87_delegate(this.getUserContactReport_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getUserContactReport_87_delegatefield));
			setUserActorPairFiltering_88_delegatefield = new setUserActorPairFiltering_88_delegate(this.setUserActorPairFiltering_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setUserActorPairFiltering_88_delegatefield));
			getUserActorPairFiltering_89_delegatefield = new getUserActorPairFiltering_89_delegate(this.getUserActorPairFiltering_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getUserActorPairFiltering_89_delegatefield));
			raycastAnyBounds_90_delegatefield = new raycastAnyBounds_90_delegate(this.raycastAnyBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyBounds_90_delegatefield));
			raycastAnyBounds_91_delegatefield = new raycastAnyBounds_91_delegate(this.raycastAnyBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyBounds_91_delegatefield));
			raycastAnyBounds_92_delegatefield = new raycastAnyBounds_92_delegate(this.raycastAnyBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyBounds_92_delegatefield));
			raycastAnyBounds_93_delegatefield = new raycastAnyBounds_93_delegate(this.raycastAnyBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyBounds_93_delegatefield));
			raycastAnyShape_94_delegatefield = new raycastAnyShape_94_delegate(this.raycastAnyShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyShape_94_delegatefield));
			raycastAnyShape_95_delegatefield = new raycastAnyShape_95_delegate(this.raycastAnyShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyShape_95_delegatefield));
			raycastAnyShape_96_delegatefield = new raycastAnyShape_96_delegate(this.raycastAnyShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyShape_96_delegatefield));
			raycastAnyShape_97_delegatefield = new raycastAnyShape_97_delegate(this.raycastAnyShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyShape_97_delegatefield));
			raycastAnyShape_98_delegatefield = new raycastAnyShape_98_delegate(this.raycastAnyShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAnyShape_98_delegatefield));
			raycastAllBounds_99_delegatefield = new raycastAllBounds_99_delegate(this.raycastAllBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllBounds_99_delegatefield));
			raycastAllBounds_100_delegatefield = new raycastAllBounds_100_delegate(this.raycastAllBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllBounds_100_delegatefield));
			raycastAllBounds_101_delegatefield = new raycastAllBounds_101_delegate(this.raycastAllBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllBounds_101_delegatefield));
			raycastAllBounds_102_delegatefield = new raycastAllBounds_102_delegate(this.raycastAllBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllBounds_102_delegatefield));
			raycastAllBounds_103_delegatefield = new raycastAllBounds_103_delegate(this.raycastAllBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllBounds_103_delegatefield));
			raycastAllShapes_104_delegatefield = new raycastAllShapes_104_delegate(this.raycastAllShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllShapes_104_delegatefield));
			raycastAllShapes_105_delegatefield = new raycastAllShapes_105_delegate(this.raycastAllShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllShapes_105_delegatefield));
			raycastAllShapes_106_delegatefield = new raycastAllShapes_106_delegate(this.raycastAllShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllShapes_106_delegatefield));
			raycastAllShapes_107_delegatefield = new raycastAllShapes_107_delegate(this.raycastAllShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllShapes_107_delegatefield));
			raycastAllShapes_108_delegatefield = new raycastAllShapes_108_delegate(this.raycastAllShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastAllShapes_108_delegatefield));
			raycastClosestBounds_109_delegatefield = new raycastClosestBounds_109_delegate(this.raycastClosestBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestBounds_109_delegatefield));
			raycastClosestBounds_110_delegatefield = new raycastClosestBounds_110_delegate(this.raycastClosestBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestBounds_110_delegatefield));
			raycastClosestBounds_111_delegatefield = new raycastClosestBounds_111_delegate(this.raycastClosestBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestBounds_111_delegatefield));
			raycastClosestBounds_112_delegatefield = new raycastClosestBounds_112_delegate(this.raycastClosestBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestBounds_112_delegatefield));
			raycastClosestBounds_113_delegatefield = new raycastClosestBounds_113_delegate(this.raycastClosestBounds_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestBounds_113_delegatefield));
			raycastClosestShape_114_delegatefield = new raycastClosestShape_114_delegate(this.raycastClosestShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestShape_114_delegatefield));
			raycastClosestShape_115_delegatefield = new raycastClosestShape_115_delegate(this.raycastClosestShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestShape_115_delegatefield));
			raycastClosestShape_116_delegatefield = new raycastClosestShape_116_delegate(this.raycastClosestShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestShape_116_delegatefield));
			raycastClosestShape_117_delegatefield = new raycastClosestShape_117_delegate(this.raycastClosestShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestShape_117_delegatefield));
			raycastClosestShape_118_delegatefield = new raycastClosestShape_118_delegate(this.raycastClosestShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestShape_118_delegatefield));
			raycastClosestShape_119_delegatefield = new raycastClosestShape_119_delegate(this.raycastClosestShape_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(raycastClosestShape_119_delegatefield));
			overlapSphereShapes_120_delegatefield = new overlapSphereShapes_120_delegate(this.overlapSphereShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapSphereShapes_120_delegatefield));
			overlapSphereShapes_121_delegatefield = new overlapSphereShapes_121_delegate(this.overlapSphereShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapSphereShapes_121_delegatefield));
			overlapSphereShapes_122_delegatefield = new overlapSphereShapes_122_delegate(this.overlapSphereShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapSphereShapes_122_delegatefield));
			overlapSphereShapes_123_delegatefield = new overlapSphereShapes_123_delegate(this.overlapSphereShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapSphereShapes_123_delegatefield));
			overlapAABBShapes_124_delegatefield = new overlapAABBShapes_124_delegate(this.overlapAABBShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapAABBShapes_124_delegatefield));
			overlapAABBShapes_125_delegatefield = new overlapAABBShapes_125_delegate(this.overlapAABBShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapAABBShapes_125_delegatefield));
			overlapAABBShapes_126_delegatefield = new overlapAABBShapes_126_delegate(this.overlapAABBShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapAABBShapes_126_delegatefield));
			overlapAABBShapes_127_delegatefield = new overlapAABBShapes_127_delegate(this.overlapAABBShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapAABBShapes_127_delegatefield));
			overlapOBBShapes_128_delegatefield = new overlapOBBShapes_128_delegate(this.overlapOBBShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapOBBShapes_128_delegatefield));
			overlapOBBShapes_129_delegatefield = new overlapOBBShapes_129_delegate(this.overlapOBBShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapOBBShapes_129_delegatefield));
			overlapOBBShapes_130_delegatefield = new overlapOBBShapes_130_delegate(this.overlapOBBShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapOBBShapes_130_delegatefield));
			overlapOBBShapes_131_delegatefield = new overlapOBBShapes_131_delegate(this.overlapOBBShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapOBBShapes_131_delegatefield));
			overlapCapsuleShapes_132_delegatefield = new overlapCapsuleShapes_132_delegate(this.overlapCapsuleShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapCapsuleShapes_132_delegatefield));
			overlapCapsuleShapes_133_delegatefield = new overlapCapsuleShapes_133_delegate(this.overlapCapsuleShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapCapsuleShapes_133_delegatefield));
			overlapCapsuleShapes_134_delegatefield = new overlapCapsuleShapes_134_delegate(this.overlapCapsuleShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapCapsuleShapes_134_delegatefield));
			overlapCapsuleShapes_135_delegatefield = new overlapCapsuleShapes_135_delegate(this.overlapCapsuleShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(overlapCapsuleShapes_135_delegatefield));
			createSweepCache_136_delegatefield = new createSweepCache_136_delegate(this.createSweepCache_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createSweepCache_136_delegatefield));
			releaseSweepCache_137_delegatefield = new releaseSweepCache_137_delegate(this.releaseSweepCache_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseSweepCache_137_delegatefield));
			linearOBBSweep_138_delegatefield = new linearOBBSweep_138_delegate(this.linearOBBSweep_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(linearOBBSweep_138_delegatefield));
			linearOBBSweep_139_delegatefield = new linearOBBSweep_139_delegate(this.linearOBBSweep_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(linearOBBSweep_139_delegatefield));
			linearOBBSweep_140_delegatefield = new linearOBBSweep_140_delegate(this.linearOBBSweep_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(linearOBBSweep_140_delegatefield));
			linearCapsuleSweep_141_delegatefield = new linearCapsuleSweep_141_delegate(this.linearCapsuleSweep_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(linearCapsuleSweep_141_delegatefield));
			linearCapsuleSweep_142_delegatefield = new linearCapsuleSweep_142_delegate(this.linearCapsuleSweep_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(linearCapsuleSweep_142_delegatefield));
			linearCapsuleSweep_143_delegatefield = new linearCapsuleSweep_143_delegate(this.linearCapsuleSweep_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(linearCapsuleSweep_143_delegatefield));
			cullShapes_144_delegatefield = new cullShapes_144_delegate(this.cullShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(cullShapes_144_delegatefield));
			cullShapes_145_delegatefield = new cullShapes_145_delegate(this.cullShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(cullShapes_145_delegatefield));
			cullShapes_146_delegatefield = new cullShapes_146_delegate(this.cullShapes_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(cullShapes_146_delegatefield));
			checkOverlapSphere_147_delegatefield = new checkOverlapSphere_147_delegate(this.checkOverlapSphere_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapSphere_147_delegatefield));
			checkOverlapSphere_148_delegatefield = new checkOverlapSphere_148_delegate(this.checkOverlapSphere_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapSphere_148_delegatefield));
			checkOverlapSphere_149_delegatefield = new checkOverlapSphere_149_delegate(this.checkOverlapSphere_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapSphere_149_delegatefield));
			checkOverlapSphere_150_delegatefield = new checkOverlapSphere_150_delegate(this.checkOverlapSphere_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapSphere_150_delegatefield));
			checkOverlapAABB_151_delegatefield = new checkOverlapAABB_151_delegate(this.checkOverlapAABB_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapAABB_151_delegatefield));
			checkOverlapAABB_152_delegatefield = new checkOverlapAABB_152_delegate(this.checkOverlapAABB_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapAABB_152_delegatefield));
			checkOverlapAABB_153_delegatefield = new checkOverlapAABB_153_delegate(this.checkOverlapAABB_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapAABB_153_delegatefield));
			checkOverlapAABB_154_delegatefield = new checkOverlapAABB_154_delegate(this.checkOverlapAABB_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapAABB_154_delegatefield));
			checkOverlapOBB_155_delegatefield = new checkOverlapOBB_155_delegate(this.checkOverlapOBB_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapOBB_155_delegatefield));
			checkOverlapOBB_156_delegatefield = new checkOverlapOBB_156_delegate(this.checkOverlapOBB_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapOBB_156_delegatefield));
			checkOverlapOBB_157_delegatefield = new checkOverlapOBB_157_delegate(this.checkOverlapOBB_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapOBB_157_delegatefield));
			checkOverlapOBB_158_delegatefield = new checkOverlapOBB_158_delegate(this.checkOverlapOBB_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapOBB_158_delegatefield));
			checkOverlapCapsule_159_delegatefield = new checkOverlapCapsule_159_delegate(this.checkOverlapCapsule_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapCapsule_159_delegatefield));
			checkOverlapCapsule_160_delegatefield = new checkOverlapCapsule_160_delegate(this.checkOverlapCapsule_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapCapsule_160_delegatefield));
			checkOverlapCapsule_161_delegatefield = new checkOverlapCapsule_161_delegate(this.checkOverlapCapsule_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapCapsule_161_delegatefield));
			checkOverlapCapsule_162_delegatefield = new checkOverlapCapsule_162_delegate(this.checkOverlapCapsule_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkOverlapCapsule_162_delegatefield));
			createFluid_163_delegatefield = new createFluid_163_delegate(this.createFluid_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createFluid_163_delegatefield));
			releaseFluid_164_delegatefield = new releaseFluid_164_delegate(this.releaseFluid_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseFluid_164_delegatefield));
			getNbFluids_165_delegatefield = new getNbFluids_165_delegate(this.getNbFluids_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbFluids_165_delegatefield));
			getFluids_166_delegatefield = new getFluids_166_delegate(this.getFluids_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getFluids_166_delegatefield));
			cookFluidMeshHotspot_167_delegatefield = new cookFluidMeshHotspot_167_delegate(this.cookFluidMeshHotspot_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(cookFluidMeshHotspot_167_delegatefield));
			cookFluidMeshHotspot_168_delegatefield = new cookFluidMeshHotspot_168_delegate(this.cookFluidMeshHotspot_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(cookFluidMeshHotspot_168_delegatefield));
			cookFluidMeshHotspot_169_delegatefield = new cookFluidMeshHotspot_169_delegate(this.cookFluidMeshHotspot_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(cookFluidMeshHotspot_169_delegatefield));
			createCloth_170_delegatefield = new createCloth_170_delegate(this.createCloth_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createCloth_170_delegatefield));
			releaseCloth_171_delegatefield = new releaseCloth_171_delegate(this.releaseCloth_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseCloth_171_delegatefield));
			getNbCloths_172_delegatefield = new getNbCloths_172_delegate(this.getNbCloths_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbCloths_172_delegatefield));
			getCloths_173_delegatefield = new getCloths_173_delegate(this.getCloths_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getCloths_173_delegatefield));
			createSoftBody_174_delegatefield = new createSoftBody_174_delegate(this.createSoftBody_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createSoftBody_174_delegatefield));
			releaseSoftBody_175_delegatefield = new releaseSoftBody_175_delegate(this.releaseSoftBody_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseSoftBody_175_delegatefield));
			getNbSoftBodies_176_delegatefield = new getNbSoftBodies_176_delegate(this.getNbSoftBodies_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getNbSoftBodies_176_delegatefield));
			getSoftBodies_177_delegatefield = new getSoftBodies_177_delegate(this.getSoftBodies_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getSoftBodies_177_delegatefield));
			saveToDesc_178_delegatefield = new saveToDesc_178_delegate(this.saveToDesc_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(saveToDesc_178_delegatefield));
			getFlags_179_delegatefield = new getFlags_179_delegate(this.getFlags_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getFlags_179_delegatefield));
			getSimType_180_delegatefield = new getSimType_180_delegate(this.getSimType_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getSimType_180_delegatefield));
			getInternal_181_delegatefield = new getInternal_181_delegate(this.getInternal_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getInternal_181_delegatefield));
			setGravity_182_delegatefield = new setGravity_182_delegate(this.setGravity_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setGravity_182_delegatefield));
			getGravity_183_delegatefield = new getGravity_183_delegate(this.getGravity_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getGravity_183_delegatefield));
			flushStream_184_delegatefield = new flushStream_184_delegate(this.flushStream_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(flushStream_184_delegatefield));
			setTiming_185_delegatefield = new setTiming_185_delegate(this.setTiming_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setTiming_185_delegatefield));
			setTiming_186_delegatefield = new setTiming_186_delegate(this.setTiming_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setTiming_186_delegatefield));
			setTiming_187_delegatefield = new setTiming_187_delegate(this.setTiming_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setTiming_187_delegatefield));
			getTiming_188_delegatefield = new getTiming_188_delegate(this.getTiming_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getTiming_188_delegatefield));
			getTiming_189_delegatefield = new getTiming_189_delegate(this.getTiming_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getTiming_189_delegatefield));
			getDebugRenderable_190_delegatefield = new getDebugRenderable_190_delegate(this.getDebugRenderable_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getDebugRenderable_190_delegatefield));
			getPhysicsSDK_191_delegatefield = new getPhysicsSDK_191_delegate(this.getPhysicsSDK_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getPhysicsSDK_191_delegatefield));
			getStats_192_delegatefield = new getStats_192_delegate(this.getStats_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getStats_192_delegatefield));
			getStats2_193_delegatefield = new getStats2_193_delegate(this.getStats2_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getStats2_193_delegatefield));
			getLimits_194_delegatefield = new getLimits_194_delegate(this.getLimits_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getLimits_194_delegatefield));
			setMaxCPUForLoadBalancing_195_delegatefield = new setMaxCPUForLoadBalancing_195_delegate(this.setMaxCPUForLoadBalancing_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setMaxCPUForLoadBalancing_195_delegatefield));
			getMaxCPUForLoadBalancing_196_delegatefield = new getMaxCPUForLoadBalancing_196_delegate(this.getMaxCPUForLoadBalancing_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getMaxCPUForLoadBalancing_196_delegatefield));
			isWritable_197_delegatefield = new isWritable_197_delegate(this.isWritable_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(isWritable_197_delegatefield));
			simulate_198_delegatefield = new simulate_198_delegate(this.simulate_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(simulate_198_delegatefield));
			checkResults_199_delegatefield = new checkResults_199_delegate(this.checkResults_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkResults_199_delegatefield));
			checkResults_200_delegatefield = new checkResults_200_delegate(this.checkResults_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(checkResults_200_delegatefield));
			fetchResults_201_delegatefield = new fetchResults_201_delegate(this.fetchResults_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(fetchResults_201_delegatefield));
			fetchResults_202_delegatefield = new fetchResults_202_delegate(this.fetchResults_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(fetchResults_202_delegatefield));
			fetchResults_203_delegatefield = new fetchResults_203_delegate(this.fetchResults_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(fetchResults_203_delegatefield));
			flushCaches_204_delegatefield = new flushCaches_204_delegate(this.flushCaches_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(flushCaches_204_delegatefield));
			readProfileData_205_delegatefield = new readProfileData_205_delegate(this.readProfileData_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(readProfileData_205_delegatefield));
			pollForWork_206_delegatefield = new pollForWork_206_delegate(this.pollForWork_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(pollForWork_206_delegatefield));
			resetPollForWork_207_delegatefield = new resetPollForWork_207_delegate(this.resetPollForWork_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(resetPollForWork_207_delegatefield));
			pollForBackgroundWork_208_delegatefield = new pollForBackgroundWork_208_delegate(this.pollForBackgroundWork_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(pollForBackgroundWork_208_delegatefield));
			shutdownWorkerThreads_209_delegatefield = new shutdownWorkerThreads_209_delegate(this.shutdownWorkerThreads_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(shutdownWorkerThreads_209_delegatefield));
			lockQueries_210_delegatefield = new lockQueries_210_delegate(this.lockQueries_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(lockQueries_210_delegatefield));
			unlockQueries_211_delegatefield = new unlockQueries_211_delegate(this.unlockQueries_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(unlockQueries_211_delegatefield));
			createSceneQuery_212_delegatefield = new createSceneQuery_212_delegate(this.createSceneQuery_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(createSceneQuery_212_delegatefield));
			releaseSceneQuery_213_delegatefield = new releaseSceneQuery_213_delegate(this.releaseSceneQuery_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(releaseSceneQuery_213_delegatefield));
			setDynamicTreeRebuildRateHint_214_delegatefield = new setDynamicTreeRebuildRateHint_214_delegate(this.setDynamicTreeRebuildRateHint_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setDynamicTreeRebuildRateHint_214_delegatefield));
			getDynamicTreeRebuildRateHint_215_delegatefield = new getDynamicTreeRebuildRateHint_215_delegate(this.getDynamicTreeRebuildRateHint_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getDynamicTreeRebuildRateHint_215_delegatefield));
			setSolverBatchSize_216_delegatefield = new setSolverBatchSize_216_delegate(this.setSolverBatchSize_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setSolverBatchSize_216_delegatefield));
			getSolverBatchSize_217_delegatefield = new getSolverBatchSize_217_delegate(this.getSolverBatchSize_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getSolverBatchSize_217_delegatefield));
			return list;
		}
	}
}
