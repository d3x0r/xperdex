//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Copyright (c) 2007-2008
// Available under the terms of the
// Eclipse Public License with GPL exception
// See enclosed license file for more information
namespace PhysX.NET
{
	using System;
	using System.Runtime.InteropServices;
	
	
	public class NxClothMesh : DoxyBindObject
	{
		
		internal NxClothMesh(IntPtr ptr) : 
				base(ptr)
		{
		}
		
		/// <summary></summary>
		protected NxClothMesh() : 
				base(IntPtr.Zero)
		{
			if ((GetType() != typeof(NxClothMesh)))
			{
				doSetFunctionPointers = true;
				SetPointer(new_NxClothMesh_INVOKE(doSetFunctionPointers));
				System.IntPtr[] pointers = CreateFunctionPointers().ToArray();
				set_pointers_INVOKE(ClassPointer, pointers, pointers.Length);
			}
			else
			{
				SetPointer(new_NxClothMesh_INVOKE(doSetFunctionPointers));
			}
			GC.ReRegisterForFinalize(this);
		}
		
		/// <summary>Saves the cloth descriptor. A cloth mesh is created via the cooker. The cooker potentially changes the order of the arrays references by the pointers points and triangles. Since saveToDesc returns the data of the cooked mesh, this data might differ from the originally provided data. Note that this is in contrast to the meshData member of NxClothDesc, which is guaranteed to provide data in the same order as that used to create the mesh. </summary>
		/// <param name="desc">The descriptor used to retrieve the state of the object. </param>
		public virtual bool saveToDesc(NxClothMeshDesc desc)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxClothMesh_saveToDesc_INVOKE(ClassPointer, doSetFunctionPointers, (desc!=null ? desc.ClassPointer : NullRef));
		}
		
		private bool saveToDesc_virtual(IntPtr desc)
		{
			return saveToDesc(NxClothMeshDesc.GetClass(desc));
		}
		
		delegate bool saveToDesc_0_delegate(IntPtr desc);
		
		
		
		
		
		
		private saveToDesc_0_delegate saveToDesc_0_delegatefield;
		
		/// <summary>Gets the number of cloth instances referencing this cloth mesh. </summary>
		public virtual uint getReferenceCount()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxClothMesh_getReferenceCount_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private uint getReferenceCount_virtual()
		{
			return getReferenceCount();
		}
		
		delegate uint getReferenceCount_1_delegate();
		
		
		
		
		
		
		private getReferenceCount_1_delegate getReferenceCount_1_delegatefield;
		
		#region Imports
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="new_NxClothMesh")]
        private extern static IntPtr new_NxClothMesh_INVOKE (System.Boolean do_override);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxClothMesh_saveToDesc")]
        private extern static System.Boolean NxClothMesh_saveToDesc_INVOKE (HandleRef classPointer, System.Boolean call_explicit, HandleRef desc);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxClothMesh_getReferenceCount")]
        private extern static System.UInt32 NxClothMesh_getReferenceCount_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		#endregion
		
		private static System.Collections.Generic.Dictionary<System.IntPtr, System.WeakReference> database = new System.Collections.Generic.Dictionary<System.IntPtr, System.WeakReference>();
		
		protected override void SetPointer(IntPtr ptr)
		{
			base.SetPointer(ptr);
			database[ptr] = new WeakReference(this);
		}
		
		public override void Dispose()
		{
			database.Remove(ClassPointer.Handle);
			base.Dispose();
		}
		
		public static NxClothMesh GetClass(IntPtr ptr)
		{
			if ((ptr == IntPtr.Zero))
			{
				return null;
			}
			System.WeakReference obj;
			if (database.TryGetValue(ptr, out obj))
			{
				if (obj.IsAlive)
				{
					return ((NxClothMesh)(obj.Target));
				}
			}
			return new NxClothMesh(ptr);
		}
		
		protected override System.Collections.Generic.List<System.IntPtr> CreateFunctionPointers()
		{
			System.Collections.Generic.List<System.IntPtr> list = base.CreateFunctionPointers();
			saveToDesc_0_delegatefield = new saveToDesc_0_delegate(this.saveToDesc_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(saveToDesc_0_delegatefield));
			getReferenceCount_1_delegatefield = new getReferenceCount_1_delegate(this.getReferenceCount_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getReferenceCount_1_delegatefield));
			return list;
		}
	}
}
