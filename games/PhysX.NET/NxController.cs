//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Copyright (c) 2007-2008
// Available under the terms of the
// Eclipse Public License with GPL exception
// See enclosed license file for more information
namespace PhysX.NET
{
	using System;
	using System.Runtime.InteropServices;
	
	
	public class NxController : DoxyBindObject
	{
		
		internal NxController(IntPtr ptr) : 
				base(ptr)
		{
		}
		
		/// <summary></summary>
		protected NxController() : 
				base(IntPtr.Zero)
		{
			if ((GetType() != typeof(NxController)))
			{
				doSetFunctionPointers = true;
				SetPointer(new_NxController_INVOKE(doSetFunctionPointers));
				System.IntPtr[] pointers = CreateFunctionPointers().ToArray();
				set_pointers_INVOKE(ClassPointer, pointers, pointers.Length);
			}
			else
			{
				SetPointer(new_NxController_INVOKE(doSetFunctionPointers));
			}
			GC.ReRegisterForFinalize(this);
		}
		
		/// <summary>Moves the character using a "collide-and-slide" algorithm. </summary>
		/// <param name="disp">a displacement vector </param>
		/// <param name="activeGroups">a filtering mask for collision groups. If a bit is set, corresponding group is active. </param>
		/// <param name="minDist">the minimum travelled distance to consider. If travelled distance is smaller, the character doesn't move. This is used to stop the recursive motion algorithm when remaining distance to travel is small. </param>
		/// <param name="collisionFlags">returned collision flags, collection of NxControllerFlag</param>
		/// <param name="sharpness">to prevent sudden height changes due to the autostep feature, the motion can be smoothed using a feedback filter. This coefficient defines the amount of smoothing. The smaller, the smoother. (1.0 means no smoothing). </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes, see NxScene::overlapAABBShapes(). </param>
		public virtual void move(ref NxVec3 disp, uint activeGroups, float minDist, ref uint collisionFlags, float sharpness, NxGroupsMask groupsMask)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxController_move_INVOKE(ClassPointer, doSetFunctionPointers, ref disp, activeGroups, minDist, ref collisionFlags, sharpness, (groupsMask!=null ? groupsMask.ClassPointer : NullRef));
		}
		
		private void move_virtual([In()] ref NxVec3 disp, uint activeGroups, float minDist, [In()] [Out()] ref uint collisionFlags, float sharpness, IntPtr groupsMask)
		{
			move(ref disp, activeGroups, minDist, ref collisionFlags, sharpness, NxGroupsMask.GetClass(groupsMask));
		}
		
		delegate void move_0_delegate([In()] ref NxVec3 disp, uint activeGroups, float minDist, [In()] [Out()] ref uint collisionFlags, float sharpness, IntPtr groupsMask);
		
		
		
		
		
		
		private move_0_delegate move_0_delegatefield;
		
		/// <summary>Moves the character using a "collide-and-slide" algorithm. </summary>
		/// <param name="disp">a displacement vector </param>
		/// <param name="activeGroups">a filtering mask for collision groups. If a bit is set, corresponding group is active. </param>
		/// <param name="minDist">the minimum travelled distance to consider. If travelled distance is smaller, the character doesn't move. This is used to stop the recursive motion algorithm when remaining distance to travel is small. </param>
		/// <param name="collisionFlags">returned collision flags, collection of NxControllerFlag</param>
		/// <param name="sharpness">to prevent sudden height changes due to the autostep feature, the motion can be smoothed using a feedback filter. This coefficient defines the amount of smoothing. The smaller, the smoother. (1.0 means no smoothing). </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes, see NxScene::overlapAABBShapes(). </param>
		public virtual void move(ref NxVec3 disp, uint activeGroups, float minDist, ref uint collisionFlags, float sharpness)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxController_move_1_INVOKE(ClassPointer, doSetFunctionPointers, ref disp, activeGroups, minDist, ref collisionFlags, sharpness);
		}
		
		private void move_virtual([In()] ref NxVec3 disp, uint activeGroups, float minDist, [In()] [Out()] ref uint collisionFlags, float sharpness)
		{
			move(ref disp, activeGroups, minDist, ref collisionFlags, sharpness);
		}
		
		delegate void move_1_delegate([In()] ref NxVec3 disp, uint activeGroups, float minDist, [In()] [Out()] ref uint collisionFlags, float sharpness);
		
		
		
		
		
		
		private move_1_delegate move_1_delegatefield;
		
		/// <summary>Moves the character using a "collide-and-slide" algorithm. </summary>
		/// <param name="disp">a displacement vector </param>
		/// <param name="activeGroups">a filtering mask for collision groups. If a bit is set, corresponding group is active. </param>
		/// <param name="minDist">the minimum travelled distance to consider. If travelled distance is smaller, the character doesn't move. This is used to stop the recursive motion algorithm when remaining distance to travel is small. </param>
		/// <param name="collisionFlags">returned collision flags, collection of NxControllerFlag</param>
		/// <param name="sharpness">to prevent sudden height changes due to the autostep feature, the motion can be smoothed using a feedback filter. This coefficient defines the amount of smoothing. The smaller, the smoother. (1.0 means no smoothing). </param>
		/// <param name="groupsMask">Alternative mask used to filter shapes, see NxScene::overlapAABBShapes(). </param>
		public virtual void move(ref NxVec3 disp, uint activeGroups, float minDist, ref uint collisionFlags)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxController_move_2_INVOKE(ClassPointer, doSetFunctionPointers, ref disp, activeGroups, minDist, ref collisionFlags);
		}
		
		private void move_virtual([In()] ref NxVec3 disp, uint activeGroups, float minDist, [In()] [Out()] ref uint collisionFlags)
		{
			move(ref disp, activeGroups, minDist, ref collisionFlags);
		}
		
		delegate void move_2_delegate([In()] ref NxVec3 disp, uint activeGroups, float minDist, [In()] [Out()] ref uint collisionFlags);
		
		
		
		
		
		
		private move_2_delegate move_2_delegatefield;
		
		/// <summary>Resets controller's position. </summary>
		/// <param name="position">The new positon for the controller. </param>
		public virtual bool setPosition(ref NxExtendedVec3 position)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxController_setPosition_INVOKE(ClassPointer, doSetFunctionPointers, ref position);
		}
		
		private bool setPosition_virtual([In()] ref NxExtendedVec3 position)
		{
			return setPosition(ref position);
		}
		
		delegate bool setPosition_3_delegate([In()] ref NxExtendedVec3 position);
		
		
		
		
		
		
		private setPosition_3_delegate setPosition_3_delegatefield;
		
		/// <summary>Retrieve the raw position of the controller. </summary>
		public virtual NxExtendedVec3[] getPosition()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxController_getPosition_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private NxExtendedVec3[] getPosition_virtual()
		{
			return getPosition();
		}
		
		delegate NxExtendedVec3[] getPosition_4_delegate();
		
		
		
		
		
		
		private getPosition_4_delegate getPosition_4_delegatefield;
		
		/// <summary>Retrieve the filtered position of the controller. </summary>
		public virtual NxExtendedVec3[] getFilteredPosition()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxController_getFilteredPosition_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private NxExtendedVec3[] getFilteredPosition_virtual()
		{
			return getFilteredPosition();
		}
		
		delegate NxExtendedVec3[] getFilteredPosition_5_delegate();
		
		
		
		
		
		
		private getFilteredPosition_5_delegate getFilteredPosition_5_delegatefield;
		
		/// <summary>Currently returns the position of the character. </summary>
		public virtual NxExtendedVec3[] getDebugPosition()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxController_getDebugPosition_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private NxExtendedVec3[] getDebugPosition_virtual()
		{
			return getDebugPosition();
		}
		
		delegate NxExtendedVec3[] getDebugPosition_6_delegate();
		
		
		
		
		
		
		private getDebugPosition_6_delegate getDebugPosition_6_delegatefield;
		
		/// <summary>Get the actor associated with this controller (see PhysX documentation). The behavior upon manually altering this actor is undefined, you should primarily use it for reading const properties. </summary>
		public virtual NxActor getActor()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxActor.GetClass(NxController_getActor_INVOKE(ClassPointer, doSetFunctionPointers));
		}
		
		private IntPtr getActor_virtual()
		{
			return getActor().ClassPointer.Handle;
		}
		
		delegate IntPtr getActor_7_delegate();
		
		
		
		
		
		
		private getActor_7_delegate getActor_7_delegatefield;
		
		/// <summary>The step height. </summary>
		/// <param name="offset">The new step offset for the controller.</param>
		public virtual void setStepOffset(float offset)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxController_setStepOffset_INVOKE(ClassPointer, doSetFunctionPointers, offset);
		}
		
		private void setStepOffset_virtual(float offset)
		{
			setStepOffset(offset);
		}
		
		delegate void setStepOffset_8_delegate(float offset);
		
		
		
		
		
		
		private setStepOffset_8_delegate setStepOffset_8_delegatefield;
		
		/// <summary>Enable/Disable collisions for this controller/actor. </summary>
		/// <param name="enabled">True to enable collision with the controller. </param>
		public virtual void setCollision(bool enabled)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxController_setCollision_INVOKE(ClassPointer, doSetFunctionPointers, enabled);
		}
		
		private void setCollision_virtual(bool enabled)
		{
			setCollision(enabled);
		}
		
		delegate void setCollision_9_delegate(bool enabled);
		
		
		
		
		
		
		private setCollision_9_delegate setCollision_9_delegatefield;
		
		/// <summary>Sets the interaction flag for the CCT. </summary>
		/// <param name="flag">The new value of the interaction flag.</param>
		public virtual void setInteraction(NxCCTInteractionFlag flag)
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxController_setInteraction_INVOKE(ClassPointer, doSetFunctionPointers, flag);
		}
		
		private void setInteraction_virtual(NxCCTInteractionFlag flag)
		{
			setInteraction(flag);
		}
		
		delegate void setInteraction_10_delegate(NxCCTInteractionFlag flag);
		
		
		
		
		
		
		private setInteraction_10_delegate setInteraction_10_delegatefield;
		
		/// <summary>Retrieves the interaction flag for the CCT. </summary>
		public virtual NxCCTInteractionFlag getInteraction()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxController_getInteraction_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private NxCCTInteractionFlag getInteraction_virtual()
		{
			return getInteraction();
		}
		
		delegate NxCCTInteractionFlag getInteraction_11_delegate();
		
		
		
		
		
		
		private getInteraction_11_delegate getInteraction_11_delegatefield;
		
		/// <summary>The character controller uses caching in order to speed up collision testing, this caching can not detect when static objects have changed in the scene. You need to call this method when such changes have been made. </summary>
		public virtual void reportSceneChanged()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			NxController_reportSceneChanged_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private void reportSceneChanged_virtual()
		{
			reportSceneChanged();
		}
		
		delegate void reportSceneChanged_12_delegate();
		
		
		
		
		
		
		private reportSceneChanged_12_delegate reportSceneChanged_12_delegatefield;
		
		/// <summary>Returns the user data associated with this controller. </summary>
		public virtual System.IntPtr getUserData()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxController_getUserData_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private System.IntPtr getUserData_virtual()
		{
			return getUserData();
		}
		
		delegate System.IntPtr getUserData_13_delegate();
		
		
		
		
		
		
		private getUserData_13_delegate getUserData_13_delegatefield;
		
		/// <summary>Return the type of controller. </summary>
		public virtual NxControllerType getType()
		{
			if (doSetFunctionPointers)
			{
				throw new System.NotSupportedException("Cannot call abstract base member");
			}
			return NxController_getType_INVOKE(ClassPointer, doSetFunctionPointers);
		}
		
		private NxControllerType getType_virtual()
		{
			return getType();
		}
		
		delegate NxControllerType getType_14_delegate();
		
		
		
		
		
		
		private getType_14_delegate getType_14_delegatefield;
		
		#region Imports
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="new_NxController")]
        private extern static IntPtr new_NxController_INVOKE (System.Boolean do_override);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_move")]
        private extern static void NxController_move_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] ref NxVec3 disp, System.UInt32 activeGroups, System.Single minDist, [In()] [Out()] ref System.UInt32 collisionFlags, System.Single sharpness, HandleRef groupsMask);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_move_1")]
        private extern static void NxController_move_1_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] ref NxVec3 disp, System.UInt32 activeGroups, System.Single minDist, [In()] [Out()] ref System.UInt32 collisionFlags, System.Single sharpness);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_move_2")]
        private extern static void NxController_move_2_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] ref NxVec3 disp, System.UInt32 activeGroups, System.Single minDist, [In()] [Out()] ref System.UInt32 collisionFlags);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_setPosition")]
        private extern static System.Boolean NxController_setPosition_INVOKE (HandleRef classPointer, System.Boolean call_explicit, [In()] ref NxExtendedVec3 position);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_getPosition")]
        private extern static NxExtendedVec3[] NxController_getPosition_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_getFilteredPosition")]
        private extern static NxExtendedVec3[] NxController_getFilteredPosition_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_getDebugPosition")]
        private extern static NxExtendedVec3[] NxController_getDebugPosition_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_getActor")]
        private extern static IntPtr NxController_getActor_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_setStepOffset")]
        private extern static void NxController_setStepOffset_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Single offset);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_setCollision")]
        private extern static void NxController_setCollision_INVOKE (HandleRef classPointer, System.Boolean call_explicit, System.Boolean enabled);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_setInteraction")]
        private extern static void NxController_setInteraction_INVOKE (HandleRef classPointer, System.Boolean call_explicit, NxCCTInteractionFlag flag);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_getInteraction")]
        private extern static NxCCTInteractionFlag NxController_getInteraction_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_reportSceneChanged")]
        private extern static void NxController_reportSceneChanged_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_getUserData")]
        private extern static System.IntPtr NxController_getUserData_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		
        [System.Security.SuppressUnmanagedCodeSecurity()]
        [DllImport(NATIVE_LIBRARY, EntryPoint="NxController_getType")]
        private extern static NxControllerType NxController_getType_INVOKE (HandleRef classPointer, System.Boolean call_explicit);

		#endregion
		
		private static System.Collections.Generic.Dictionary<System.IntPtr, System.WeakReference> database = new System.Collections.Generic.Dictionary<System.IntPtr, System.WeakReference>();
		
		protected override void SetPointer(IntPtr ptr)
		{
			base.SetPointer(ptr);
			database[ptr] = new WeakReference(this);
		}
		
		public override void Dispose()
		{
			database.Remove(ClassPointer.Handle);
			base.Dispose();
		}
		
		public static NxController GetClass(IntPtr ptr)
		{
			if ((ptr == IntPtr.Zero))
			{
				return null;
			}
			System.WeakReference obj;
			if (database.TryGetValue(ptr, out obj))
			{
				if (obj.IsAlive)
				{
					return ((NxController)(obj.Target));
				}
			}
			return new NxController(ptr);
		}
		
		protected override System.Collections.Generic.List<System.IntPtr> CreateFunctionPointers()
		{
			System.Collections.Generic.List<System.IntPtr> list = base.CreateFunctionPointers();
			move_0_delegatefield = new move_0_delegate(this.move_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(move_0_delegatefield));
			move_1_delegatefield = new move_1_delegate(this.move_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(move_1_delegatefield));
			move_2_delegatefield = new move_2_delegate(this.move_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(move_2_delegatefield));
			setPosition_3_delegatefield = new setPosition_3_delegate(this.setPosition_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setPosition_3_delegatefield));
			getPosition_4_delegatefield = new getPosition_4_delegate(this.getPosition_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getPosition_4_delegatefield));
			getFilteredPosition_5_delegatefield = new getFilteredPosition_5_delegate(this.getFilteredPosition_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getFilteredPosition_5_delegatefield));
			getDebugPosition_6_delegatefield = new getDebugPosition_6_delegate(this.getDebugPosition_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getDebugPosition_6_delegatefield));
			getActor_7_delegatefield = new getActor_7_delegate(this.getActor_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getActor_7_delegatefield));
			setStepOffset_8_delegatefield = new setStepOffset_8_delegate(this.setStepOffset_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setStepOffset_8_delegatefield));
			setCollision_9_delegatefield = new setCollision_9_delegate(this.setCollision_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setCollision_9_delegatefield));
			setInteraction_10_delegatefield = new setInteraction_10_delegate(this.setInteraction_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(setInteraction_10_delegatefield));
			getInteraction_11_delegatefield = new getInteraction_11_delegate(this.getInteraction_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getInteraction_11_delegatefield));
			reportSceneChanged_12_delegatefield = new reportSceneChanged_12_delegate(this.reportSceneChanged_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(reportSceneChanged_12_delegatefield));
			getUserData_13_delegatefield = new getUserData_13_delegate(this.getUserData_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getUserData_13_delegatefield));
			getType_14_delegatefield = new getType_14_delegate(this.getType_virtual);
			list.Add(Marshal.GetFunctionPointerForDelegate(getType_14_delegatefield));
			return list;
		}
	}
}
